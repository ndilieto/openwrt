From 52c602c262ed6fd3e23c7cbb3df4a4c1e3b67c34 Mon Sep 17 00:00:00 2001
From: Daniel Schwierzeck <daniel.schwierzeck@gmail.com>
Date: Tue, 5 Nov 2013 23:22:58 +0100
Subject: [PATCH 108/158] MIPS: add support for Lantiq XWAY VRX200 family

Signed-off-by: Eddi De Pieri <eddi@depieri.net>
Signed-off-by: Daniel Schwierzeck <daniel.schwierzeck@gmail.com>
---
 arch/mips/cpu/mips32/vrx200/Makefile       |   8 +
 arch/mips/cpu/mips32/vrx200/cgu.c          | 208 +++++++++
 arch/mips/cpu/mips32/vrx200/cgu_init.S     | 119 +++++
 arch/mips/cpu/mips32/vrx200/chipid.c       |  62 +++
 arch/mips/cpu/mips32/vrx200/config.mk      |  22 +
 arch/mips/cpu/mips32/vrx200/dcdc.c         | 106 +++++
 arch/mips/cpu/mips32/vrx200/ebu.c          | 137 ++++++
 arch/mips/cpu/mips32/vrx200/gphy.c         |  44 ++
 arch/mips/cpu/mips32/vrx200/mem.c          | 694 +++++++++++++++++++++++++++++
 arch/mips/cpu/mips32/vrx200/pmu.c          | 130 ++++++
 arch/mips/cpu/mips32/vrx200/rcu.c          | 194 ++++++++
 arch/mips/include/asm/arch-vrx200/config.h | 202 +++++++++
 arch/mips/include/asm/arch-vrx200/gphy.h   |  65 +++
 arch/mips/include/asm/arch-vrx200/gpio.h   |  12 +
 arch/mips/include/asm/arch-vrx200/soc.h    |  46 ++
 arch/mips/include/asm/arch-vrx200/switch.h | 502 +++++++++++++++++++++
 16 files changed, 2551 insertions(+)
 create mode 100644 arch/mips/cpu/mips32/vrx200/Makefile
 create mode 100644 arch/mips/cpu/mips32/vrx200/cgu.c
 create mode 100644 arch/mips/cpu/mips32/vrx200/cgu_init.S
 create mode 100644 arch/mips/cpu/mips32/vrx200/chipid.c
 create mode 100644 arch/mips/cpu/mips32/vrx200/config.mk
 create mode 100644 arch/mips/cpu/mips32/vrx200/dcdc.c
 create mode 100644 arch/mips/cpu/mips32/vrx200/ebu.c
 create mode 100644 arch/mips/cpu/mips32/vrx200/gphy.c
 create mode 100644 arch/mips/cpu/mips32/vrx200/mem.c
 create mode 100644 arch/mips/cpu/mips32/vrx200/pmu.c
 create mode 100644 arch/mips/cpu/mips32/vrx200/rcu.c
 create mode 100644 arch/mips/include/asm/arch-vrx200/config.h
 create mode 100644 arch/mips/include/asm/arch-vrx200/gphy.h
 create mode 100644 arch/mips/include/asm/arch-vrx200/gpio.h
 create mode 100644 arch/mips/include/asm/arch-vrx200/soc.h
 create mode 100644 arch/mips/include/asm/arch-vrx200/switch.h

diff --git a/arch/mips/cpu/mips32/vrx200/Makefile b/arch/mips/cpu/mips32/vrx200/Makefile
new file mode 100644
index 0000000000..7fdce843cf
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/Makefile
@@ -0,0 +1,8 @@
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	+= cgu.o chipid.o dcdc.o ebu.o gphy.o mem.o pmu.o rcu.o
+obj-y	+= cgu_init.o
diff --git a/arch/mips/cpu/mips32/vrx200/cgu.c b/arch/mips/cpu/mips32/vrx200/cgu.c
new file mode 100644
index 0000000000..799c902cc7
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/cgu.c
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/gphy.h>
+#include <asm/lantiq/clk.h>
+#include <asm/lantiq/io.h>
+
+#define LTQ_CGU_PLL1_PLLN_SHIFT		6
+#define LTQ_CGU_PLL1_PLLN_MASK		(0x3F << LTQ_CGU_PLL1_PLLN_SHIFT)
+#define LTQ_CGU_PLL1_PLLM_SHIFT		2
+#define LTQ_CGU_PLL1_PLLM_MASK		(0xF << LTQ_CGU_PLL1_PLLM_SHIFT)
+#define LTQ_CGU_PLL1_PLLL		(1 << 1)
+#define LTQ_CGU_PLL1_PLL_EN		1
+
+#define LTQ_CGU_SYS_OCP_SHIFT		0
+#define LTQ_CGU_SYS_OCP_MASK		(0x3 << LTQ_CGU_SYS_OCP_SHIFT)
+#define LTQ_CGU_SYS_CPU_SHIFT		4
+#define LTQ_CGU_SYS_CPU_MASK		(0xF << LTQ_CGU_SYS_CPU_SHIFT)
+
+#define LTQ_CGU_UPDATE			1
+
+#define LTQ_CGU_IFCLK_GPHY_SEL_SHIFT	2
+#define LTQ_CGU_IFCLK_GPHY_SEL_MASK	(0x7 << LTQ_CGU_IFCLK_GPHY_SEL_SHIFT)
+
+struct ltq_cgu_regs {
+	u32	rsvd0;
+	u32	pll0_cfg;	/* PLL0 config */
+	u32	pll1_cfg;	/* PLL1 config */
+	u32	sys;		/* System clock */
+	u32	clk_fsr;	/* Clock frequency select */
+	u32	clk_gsr;	/* Clock gating status */
+	u32	clk_gcr0;	/* Clock gating control 0 */
+	u32	clk_gcr1;	/* Clock gating control 1 */
+	u32	update;		/* CGU update control */
+	u32	if_clk;		/* Interface clock */
+	u32	ddr;		/* DDR memory control */
+	u32	ct1_sr;		/* CT status 1 */
+	u32	ct_kval;	/* CT K value */
+	u32	pcm_cr;		/* PCM control */
+	u32	pci_cr;		/* PCI clock control */
+	u32	rsvd1;
+	u32	gphy1_cfg;	/* GPHY1 config */
+	u32	gphy0_cfg;	/* GPHY0 config */
+	u32	rsvd2[6];
+	u32	pll2_cfg;	/* PLL2 config */
+};
+
+static struct ltq_cgu_regs *ltq_cgu_regs =
+	(struct ltq_cgu_regs *) CKSEG1ADDR(LTQ_CGU_BASE);
+
+static inline u32 ltq_cgu_sys_readl(u32 mask, u32 shift)
+{
+	return (ltq_readl(&ltq_cgu_regs->sys) & mask) >> shift;
+}
+
+unsigned long ltq_get_io_region_clock(void)
+{
+	unsigned int ocp_sel;
+	unsigned long clk, cpu_clk;
+
+	cpu_clk = ltq_get_cpu_clock();
+
+	ocp_sel = ltq_cgu_sys_readl(LTQ_CGU_SYS_OCP_MASK,
+			LTQ_CGU_SYS_OCP_SHIFT);
+
+	switch (ocp_sel) {
+	case 0:
+		/* OCP ratio 1 */
+		clk = cpu_clk;
+		break;
+	case 2:
+		/* OCP ratio 2 */
+		clk = cpu_clk / 2;
+		break;
+	case 3:
+		/* OCP ratio 2.5 */
+		clk = (cpu_clk * 2) / 5;
+		break;
+	case 4:
+		/* OCP ratio 3 */
+		clk = cpu_clk / 3;
+		break;
+	default:
+		clk = 0;
+		break;
+	}
+
+	return clk;
+}
+
+unsigned long ltq_get_cpu_clock(void)
+{
+	unsigned int cpu_sel;
+	unsigned long clk;
+
+	cpu_sel = ltq_cgu_sys_readl(LTQ_CGU_SYS_CPU_MASK,
+			LTQ_CGU_SYS_CPU_SHIFT);
+
+	switch (cpu_sel) {
+	case 0:
+		clk = CLOCK_600_MHZ;
+		break;
+	case 1:
+		clk = CLOCK_500_MHZ;
+		break;
+	case 2:
+		clk = CLOCK_393_MHZ;
+		break;
+	case 3:
+		clk = CLOCK_333_MHZ;
+		break;
+	case 5:
+	case 6:
+		clk = CLOCK_197_MHZ;
+		break;
+	case 7:
+		clk = CLOCK_166_MHZ;
+		break;
+	case 4:
+	case 8:
+	case 9:
+		clk = CLOCK_125_MHZ;
+		break;
+	default:
+		clk = 0;
+		break;
+	}
+
+	return clk;
+}
+
+unsigned long ltq_get_bus_clock(void)
+{
+	return ltq_get_io_region_clock();
+}
+
+void ltq_cgu_gphy_clk_src(enum ltq_gphy_clk clk)
+{
+	ltq_clrbits(&ltq_cgu_regs->if_clk, LTQ_CGU_IFCLK_GPHY_SEL_MASK);
+	ltq_setbits(&ltq_cgu_regs->if_clk, clk << LTQ_CGU_IFCLK_GPHY_SEL_SHIFT);
+}
+
+static inline int ltq_cgu_pll1_locked(void)
+{
+	u32 pll1_cfg = ltq_readl(&ltq_cgu_regs->pll1_cfg);
+
+	return pll1_cfg & LTQ_CGU_PLL1_PLLL;
+}
+
+static inline void ltq_cgu_pll1_restart(unsigned m, unsigned n)
+{
+	u32 pll1_cfg;
+
+	ltq_clrbits(&ltq_cgu_regs->pll1_cfg, LTQ_CGU_PLL1_PLL_EN);
+	ltq_setbits(&ltq_cgu_regs->update, LTQ_CGU_UPDATE);
+
+	pll1_cfg = ltq_readl(&ltq_cgu_regs->pll1_cfg);
+	pll1_cfg &= ~(LTQ_CGU_PLL1_PLLN_MASK | LTQ_CGU_PLL1_PLLM_MASK);
+	pll1_cfg |= n << LTQ_CGU_PLL1_PLLN_SHIFT;
+	pll1_cfg |= m << LTQ_CGU_PLL1_PLLM_SHIFT;
+	pll1_cfg |= LTQ_CGU_PLL1_PLL_EN;
+	ltq_writel(&ltq_cgu_regs->pll1_cfg, pll1_cfg);
+	ltq_setbits(&ltq_cgu_regs->update, LTQ_CGU_UPDATE);
+
+	__udelay(1000);
+}
+
+/*
+ * From chapter 9 in errata sheet:
+ *
+ * Under certain condition, the PLL1 may failed to enter into lock
+ * status by hardware default N, M setting.
+ *
+ * Since system always starts from PLL0, the system software can run
+ * and re-program the PLL1 settings.
+ */
+static void ltq_cgu_pll1_init(void)
+{
+	unsigned i;
+	const unsigned pll1_m[] = { 1, 2, 3, 4 };
+	const unsigned pll1_n[] = { 21, 32, 43, 54 };
+
+	/* Check if PLL1 has locked with hardware default settings */
+	if (ltq_cgu_pll1_locked())
+		return;
+
+	for (i = 0; i < 4; i++) {
+		ltq_cgu_pll1_restart(pll1_m[i], pll1_n[i]);
+
+		if (ltq_cgu_pll1_locked())
+			goto done;
+	}
+
+done:
+	/* Restart with hardware default values M=5, N=64 */
+	ltq_cgu_pll1_restart(5, 64);
+}
+
+void ltq_pll_init(void)
+{
+	ltq_cgu_pll1_init();
+}
diff --git a/arch/mips/cpu/mips32/vrx200/cgu_init.S b/arch/mips/cpu/mips32/vrx200/cgu_init.S
new file mode 100644
index 0000000000..190ef89d46
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/cgu_init.S
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+#include <asm/asm.h>
+#include <asm/regdef.h>
+#include <asm/addrspace.h>
+#include <asm/arch/soc.h>
+
+/* RCU module register */
+#define LTQ_RCU_RST_REQ			0x0010	/* Reset request */
+#define LTQ_RCU_RST_REQ_VALUE		((1 << 14) | (1 << 1))
+
+/* CGU module register */
+#define LTQ_CGU_PLL0_CFG		0x0004	/* PLL0 config */
+#define LTQ_CGU_PLL1_CFG		0x0008	/* PLL1 config */
+#define LTQ_CGU_PLL2_CFG		0x0060	/* PLL2 config */
+#define LTQ_CGU_SYS			0x000C	/* System clock */
+#define LTQ_CGU_CLK_FSR			0x0010	/* Clock frequency select */
+#define LTQ_CGU_UPDATE			0x0020	/* Clock update control */
+
+/* Valid SYS.CPU values */
+#define LTQ_CGU_SYS_CPU_SHIFT		4
+#define LTQ_CGU_SYS_CPU_600_MHZ		0x0
+#define LTQ_CGU_SYS_CPU_500_MHZ		0x1
+#define LTQ_CGU_SYS_CPU_393_MHZ		0x2
+#define LTQ_CGU_SYS_CPU_333_MHZ		0x3
+#define LTQ_CGU_SYS_CPU_197_MHZ		0x5
+#define LTQ_CGU_SYS_CPU_166_MHZ		0x7
+#define LTQ_CGU_SYS_CPU_125_MHZ		0x9
+
+/* Valid SYS.OCP values */
+#define LTQ_CGU_SYS_OCP_SHIFT		0
+#define LTQ_CGU_SYS_OCP_1		0x0
+#define LTQ_CGU_SYS_OCP_2		0x2
+#define LTQ_CGU_SYS_OCP_2_5		0x3
+#define LTQ_CGU_SYS_OCP_3		0x4
+
+/* Valid CLK_FSR.ETH values */
+#define LTQ_CGU_CLK_FSR_ETH_SHIFT	24
+#define LTQ_CGU_CLK_FSR_ETH_50_MHZ	0x0
+#define LTQ_CGU_CLK_FSR_ETH_25_MHZ	0x1
+#define LTQ_CGU_CLK_FSR_ETH_2_5_MHZ	0x2
+#define LTQ_CGU_CLK_FSR_ETH_125_MHZ	0x3
+
+/* Valid CLK_FSR.PPE values */
+#define LTQ_CGU_CLK_FSR_PPE_SHIFT	16
+#define LTQ_CGU_CLK_FSR_PPE_500_MHZ	0x0	/* Overclock frequency */
+#define LTQ_CGU_CLK_FSR_PPE_450_MHZ	0x1	/* High frequency */
+#define LTQ_CGU_CLK_FSR_PPE_400_MHZ	0x2	/* Low frequency */
+
+#if (CONFIG_SYS_CLOCK_MODE == LTQ_CLK_CPU_500_DDR_250)
+#define LTQ_CGU_SYS_CPU_CONFIG		LTQ_CGU_SYS_CPU_500_MHZ
+#define LTQ_CGU_SYS_OCP_CONFIG		LTQ_CGU_SYS_OCP_2
+#define LTQ_CGU_CLK_FSR_ETH_CONFIG	LTQ_CGU_CLK_FSR_ETH_125_MHZ
+#define LTQ_CGU_CLK_FSR_PPE_CONFIG	LTQ_CGU_CLK_FSR_PPE_450_MHZ
+#else
+#error "Invalid system clock configuration!"
+#endif
+
+/* Build register values */
+#define LTQ_CGU_SYS_VALUE	((LTQ_CGU_SYS_CPU_CONFIG << \
+					LTQ_CGU_SYS_CPU_SHIFT) | \
+					LTQ_CGU_SYS_OCP_CONFIG)
+
+#define LTQ_CGU_CLK_FSR_VALUE	((LTQ_CGU_CLK_FSR_ETH_CONFIG << \
+					LTQ_CGU_CLK_FSR_ETH_SHIFT) | \
+				(LTQ_CGU_CLK_FSR_PPE_CONFIG << \
+					LTQ_CGU_CLK_FSR_PPE_SHIFT))
+
+	.set noreorder
+
+LEAF(ltq_cgu_init)
+	/* Load current CGU register values */
+	li	t0, (LTQ_CGU_BASE | KSEG1)
+	lw	t1, LTQ_CGU_SYS(t0)
+	lw	t2, LTQ_CGU_CLK_FSR(t0)
+
+	/* Load target CGU register values */
+	li	t3, LTQ_CGU_SYS_VALUE
+	li	t4, LTQ_CGU_CLK_FSR_VALUE
+
+	/* Only update registers if values differ */
+	bne	t1, t3, update
+	 nop
+	beq	t2, t4, finished
+	 nop
+
+update:
+	/* Store target register values */
+	sw	t3, LTQ_CGU_SYS(t0)
+	sw	t4, LTQ_CGU_CLK_FSR(t0)
+
+	/* Perform software reset to activate new clock config */
+#if 0
+	li	t0, (LTQ_RCU_BASE | KSEG1)
+	lw	t1, LTQ_RCU_RST_REQ(t0)
+	or	t1, LTQ_RCU_RST_REQ_VALUE
+	sw	t1, LTQ_RCU_RST_REQ(t0)
+#else
+	li	t1, 1
+	sw	t1, LTQ_CGU_UPDATE(t0)
+#endif
+
+#if 0
+wait_reset:
+	b	wait_reset
+	 nop
+#endif
+
+finished:
+	jr	ra
+	 nop
+
+	END(ltq_cgu_init)
diff --git a/arch/mips/cpu/mips32/vrx200/chipid.c b/arch/mips/cpu/mips32/vrx200/chipid.c
new file mode 100644
index 0000000000..f916e87553
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/chipid.c
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/chipid.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_CHIPID_VERSION_SHIFT	28
+#define LTQ_CHIPID_VERSION_MASK		(0x7 << LTQ_CHIPID_VERSION_SHIFT)
+#define LTQ_CHIPID_PNUM_SHIFT		12
+#define LTQ_CHIPID_PNUM_MASK		(0xFFFF << LTQ_CHIPID_PNUM_SHIFT)
+
+struct ltq_chipid_regs {
+	u32	manid;		/* Manufacturer identification */
+	u32	chipid;		/* Chip identification */
+};
+
+static struct ltq_chipid_regs *ltq_chipid_regs =
+	(struct ltq_chipid_regs *) CKSEG1ADDR(LTQ_CHIPID_BASE);
+
+unsigned int ltq_chip_version_get(void)
+{
+	u32 chipid;
+
+	chipid = ltq_readl(&ltq_chipid_regs->chipid);
+
+	return (chipid & LTQ_CHIPID_VERSION_MASK) >> LTQ_CHIPID_VERSION_SHIFT;
+}
+
+unsigned int ltq_chip_partnum_get(void)
+{
+	u32 chipid;
+
+	chipid = ltq_readl(&ltq_chipid_regs->chipid);
+
+	return (chipid & LTQ_CHIPID_PNUM_MASK) >> LTQ_CHIPID_PNUM_SHIFT;
+}
+
+const char *ltq_chip_partnum_str(void)
+{
+	enum ltq_chip_partnum partnum = ltq_chip_partnum_get();
+
+	switch (partnum) {
+	case LTQ_SOC_VRX268:
+	case LTQ_SOC_VRX268_2:
+		return "VRX268";
+	case LTQ_SOC_VRX288:
+	case LTQ_SOC_VRX288_2:
+		return "VRX288";
+	case LTQ_SOC_GRX288:
+	case LTQ_SOC_GRX288_2:
+		return "GRX288";
+	default:
+		printf("Unknown partnum: %x\n", partnum);
+	}
+
+	return "";
+}
diff --git a/arch/mips/cpu/mips32/vrx200/config.mk b/arch/mips/cpu/mips32/vrx200/config.mk
new file mode 100644
index 0000000000..5cf3c25a53
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/config.mk
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+PF_CPPFLAGS_XRX := $(call cc-option,-mtune=34kc,)
+PLATFORM_CPPFLAGS += $(PF_CPPFLAGS_XRX)
+
+libs-y += $(CPUDIR)/lantiq-common/
+
+ifndef CONFIG_SPL_BUILD
+ifdef CONFIG_SYS_BOOT_SFSPL
+ALL-$(CONFIG_SPL_LZO_SUPPORT) += u-boot.ltq.lzo.sfspl
+endif
+ifdef CONFIG_SYS_BOOT_NORSPL
+ALL-$(CONFIG_SPL_LZO_SUPPORT) += u-boot.ltq.lzo.norspl
+endif
+ifdef CONFIG_SYS_BOOT_NANDSPL
+ALL-$(CONFIG_SPL_LZO_SUPPORT) += u-boot.ltq.lzo.nandspl
+endif
+endif
diff --git a/arch/mips/cpu/mips32/vrx200/dcdc.c b/arch/mips/cpu/mips32/vrx200/dcdc.c
new file mode 100644
index 0000000000..11ca0d768b
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/dcdc.c
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/io.h>
+
+#define LTQ_DCDC_CLK_SET0_CLK_SEL_P		(1 << 6)
+#define LTQ_DCDC_CLK_SET1_SEL_DIV25		(1 << 5)
+#define LTQ_DCDC_CONF_TEST_DIG_PID_FREEZE	(1 << 5)
+
+struct ltq_dcdc_regs {
+	u8	b0_coeh;		/* Coefficient b0 */
+	u8	b0_coel;		/* Coefficient b0 */
+	u8	b1_coeh;		/* Coefficient b1 */
+	u8	b1_coel;		/* Coefficient b1 */
+	u8	b2_coeh;		/* Coefficient b2 */
+	u8	b2_coel;		/* Coefficient b2 */
+	u8	clk_set0;		/* Clock setup */
+	u8	clk_set1;		/* Clock setup */
+	u8	pwm_confh;		/* Configure PWM */
+	u8	pwm_confl;		/* Configure PWM */
+	u8	bias_vreg0;		/* Bias and regulator setup */
+	u8	bias_vreg1;		/* Bias and regulator setup */
+	u8	adc_gen0;		/* ADC and general control */
+	u8	adc_gen1;		/* ADC and general control */
+	u8	adc_con0;		/* ADC and general config */
+	u8	adc_con1;		/* ADC and general config */
+	u8	conf_test_ana;		/* not documented */
+	u8	conf_test_dig;		/* not documented */
+	u8	dcdc_status;		/* not documented */
+	u8	pid_status;		/* not documented */
+	u8	duty_cycle;		/* not documented */
+	u8	non_ov_delay;		/* not documented */
+	u8	analog_gain;		/* not documented */
+	u8	duty_cycle_max_sat;	/* not documented */
+	u8	duty_cycle_min_sat;	/* not documented */
+	u8	duty_cycle_max;		/* not documented */
+	u8	duty_cycle_min;		/* not documented */
+	u8	error_max;		/* not documented */
+	u8	error_read;		/* not documented */
+	u8	delay_deglitch;		/* not documented */
+	u8	latch_control;		/* not documented */
+	u8	rsvd[240];
+	u8	osc_conf;		/* OSC general config */
+	u8	osc_stat;		/* OSC general status */
+};
+
+static struct ltq_dcdc_regs *ltq_dcdc_regs =
+	(struct ltq_dcdc_regs *) CKSEG1ADDR(LTQ_DCDC_BASE);
+
+void ltq_dcdc_init(unsigned int dig_ref)
+{
+	u8 dig_ref_cur, val;
+
+	/* Set duty cycle max sat. to 70/90, enable PID freeze */
+	ltq_writeb(&ltq_dcdc_regs->duty_cycle_max_sat, 0x5A);
+	ltq_writeb(&ltq_dcdc_regs->duty_cycle_min_sat, 0x46);
+	val = ltq_readb(&ltq_dcdc_regs->conf_test_dig);
+	val |= LTQ_DCDC_CONF_TEST_DIG_PID_FREEZE;
+	ltq_writeb(&ltq_dcdc_regs->conf_test_dig, val);
+
+	/* Program new coefficients */
+	ltq_writeb(&ltq_dcdc_regs->b0_coeh, 0x00);
+	ltq_writeb(&ltq_dcdc_regs->b0_coel, 0x00);
+	ltq_writeb(&ltq_dcdc_regs->b1_coeh, 0xFF);
+	ltq_writeb(&ltq_dcdc_regs->b1_coel, 0xE6);
+	ltq_writeb(&ltq_dcdc_regs->b2_coeh, 0x00);
+	ltq_writeb(&ltq_dcdc_regs->b2_coel, 0x1B);
+	ltq_writeb(&ltq_dcdc_regs->non_ov_delay, 0x8B);
+
+	/* Set duty cycle max sat. to 60/108, disable PID freeze */
+	ltq_writeb(&ltq_dcdc_regs->duty_cycle_max_sat, 0x6C);
+	ltq_writeb(&ltq_dcdc_regs->duty_cycle_min_sat, 0x3C);
+	val = ltq_readb(&ltq_dcdc_regs->conf_test_dig);
+	val &= ~LTQ_DCDC_CONF_TEST_DIG_PID_FREEZE;
+	ltq_writeb(&ltq_dcdc_regs->conf_test_dig, val);
+
+	/* Init clock and DLL settings */
+	val = ltq_readb(&ltq_dcdc_regs->clk_set0);
+	val |= LTQ_DCDC_CLK_SET0_CLK_SEL_P;
+	ltq_writeb(&ltq_dcdc_regs->clk_set0, val);
+	val = ltq_readb(&ltq_dcdc_regs->clk_set1);
+	val |= LTQ_DCDC_CLK_SET1_SEL_DIV25;
+	ltq_writeb(&ltq_dcdc_regs->clk_set1, val);
+	ltq_writeb(&ltq_dcdc_regs->pwm_confh, 0xF9);
+
+	wmb();
+
+	/* Adapt value of digital reference of DCDC converter */
+	dig_ref_cur = ltq_readb(&ltq_dcdc_regs->bias_vreg1);
+
+	while (dig_ref_cur != dig_ref) {
+		if (dig_ref >= dig_ref_cur)
+			dig_ref_cur++;
+		else if (dig_ref < dig_ref_cur)
+			dig_ref_cur--;
+
+		ltq_writeb(&ltq_dcdc_regs->bias_vreg1, dig_ref_cur);
+		__udelay(1000);
+	}
+}
diff --git a/arch/mips/cpu/mips32/vrx200/ebu.c b/arch/mips/cpu/mips32/vrx200/ebu.c
new file mode 100644
index 0000000000..c48ab77c59
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/ebu.c
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/io.h>
+
+#define EBU_ADDRSEL_MASK(mask)		((mask & 0xf) << 4)
+#define EBU_ADDRSEL_REGEN		(1 << 0)
+
+#define EBU_CON_WRDIS			(1 << 31)
+#define EBU_CON_AGEN_DEMUX		(0x0 << 24)
+#define EBU_CON_AGEN_MUX		(0x2 << 24)
+#define EBU_CON_SETUP			(1 << 22)
+#define EBU_CON_WAIT_DIS		(0x0 << 20)
+#define EBU_CON_WAIT_ASYNC		(0x1 << 20)
+#define EBU_CON_WAIT_SYNC		(0x2 << 20)
+#define EBU_CON_WINV			(1 << 19)
+#define EBU_CON_PW_8BIT			(0x0 << 16)
+#define EBU_CON_PW_16BIT		(0x1 << 16)
+#define EBU_CON_ALEC(cycles)		((cycles & 0x3) << 14)
+#define EBU_CON_BCGEN_CS		(0x0 << 12)
+#define EBU_CON_BCGEN_INTEL		(0x1 << 12)
+#define EBU_CON_BCGEN_MOTOROLA		(0x2 << 12)
+#define EBU_CON_WAITWRC(cycles)		((cycles & 0x7) << 8)
+#define EBU_CON_WAITRDC(cycles)		((cycles & 0x3) << 6)
+#define EBU_CON_HOLDC(cycles)		((cycles & 0x3) << 4)
+#define EBU_CON_RECOVC(cycles)		((cycles & 0x3) << 2)
+#define EBU_CON_CMULT_1			0x0
+#define EBU_CON_CMULT_4			0x1
+#define EBU_CON_CMULT_8			0x2
+#define EBU_CON_CMULT_16		0x3
+
+#define EBU_CON_DEFAULT_NOR	(EBU_CON_AGEN_DEMUX | EBU_CON_WAIT_DIS | \
+				EBU_CON_PW_16BIT | EBU_CON_ALEC(3) | \
+				EBU_CON_BCGEN_INTEL | EBU_CON_WAITWRC(7) | \
+				EBU_CON_WAITRDC(3) | EBU_CON_HOLDC(3) | \
+				EBU_CON_RECOVC(3) | EBU_CON_CMULT_16)
+
+#define EBU_CON_DEFAULT_NAND	(EBU_CON_AGEN_DEMUX | EBU_CON_SETUP | \
+				EBU_CON_WAIT_DIS | EBU_CON_PW_8BIT | \
+				EBU_CON_ALEC(3) | EBU_CON_BCGEN_INTEL | \
+				EBU_CON_WAITWRC(2) | EBU_CON_WAITRDC(2) | \
+				EBU_CON_HOLDC(1) | EBU_CON_RECOVC(1) | \
+				EBU_CON_CMULT_4)
+
+#if defined(CONFIG_LTQ_SUPPORT_NOR_FLASH)
+#define ebu_region0_nor			1
+#if (CONFIG_SYS_MAX_FLASH_BANKS == 2)
+#define ebu_region1_nor			1
+#else
+#define ebu_region1_nor			0
+#endif
+#else
+#define ebu_region0_nor			0
+#define ebu_region1_nor			0
+#endif
+
+#if ((CONFIG_SYS_MAX_FLASH_BANKS == 2) && defined(CONFIG_LTQ_SUPPORT_NOR_FLASH))
+#define ebu_region1_enable		1
+#define ebu_region0_addrsel_mask	3
+#else
+#define ebu_region0_addrsel_mask	1
+#define ebu_region1_enable		0
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_NAND_FLASH)
+#if defined(CONFIG_LTQ_NAND_CS0)
+#define ebu_region0_nand		1
+#else
+#define ebu_region0_nand		0
+#endif
+#if defined(CONFIG_LTQ_NAND_CS1)
+#define ebu_region1_nand		1
+#else
+#define ebu_region1_nand		0
+#endif
+#else
+#define ebu_region0_nand		0
+#define ebu_region1_nand		0
+#endif
+
+struct ltq_ebu_regs {
+	u32	clc;
+	u32	rsvd0;
+	u32	id;
+	u32	rsvd1;
+	u32	con;
+	u32	rsvd2[3];
+	u32	addr_sel_0;
+	u32	addr_sel_1;
+	u32	addr_sel_2;
+	u32	addr_sel_3;
+	u32	rsvd3[12];
+	u32	con_0;
+	u32	con_1;
+	u32	con_2;
+	u32	con_3;
+};
+
+static struct ltq_ebu_regs *ltq_ebu_regs =
+	(struct ltq_ebu_regs *) CKSEG1ADDR(LTQ_EBU_BASE);
+
+void ltq_ebu_init(void)
+{
+	if (ebu_region0_nor || ebu_region0_nand)
+		ltq_writel(&ltq_ebu_regs->addr_sel_0, LTQ_EBU_REGION0_BASE |
+			EBU_ADDRSEL_MASK(3) | EBU_ADDRSEL_REGEN);
+	else
+		ltq_clrbits(&ltq_ebu_regs->addr_sel_0, EBU_ADDRSEL_REGEN);
+
+	if (ebu_region1_nor || ebu_region1_nand)
+		ltq_writel(&ltq_ebu_regs->addr_sel_1, LTQ_EBU_REGION1_BASE |
+			EBU_ADDRSEL_MASK(3) | EBU_ADDRSEL_REGEN);
+	else
+		ltq_clrbits(&ltq_ebu_regs->addr_sel_1, EBU_ADDRSEL_REGEN);
+
+	if (ebu_region0_nor)
+		ltq_writel(&ltq_ebu_regs->con_0, EBU_CON_DEFAULT_NOR);
+
+	if (ebu_region1_nor)
+		ltq_writel(&ltq_ebu_regs->con_1, EBU_CON_DEFAULT_NOR);
+
+	if (ebu_region0_nand)
+		ltq_writel(&ltq_ebu_regs->con_0, EBU_CON_DEFAULT_NAND);
+
+	if (ebu_region1_nand)
+		ltq_writel(&ltq_ebu_regs->con_1, EBU_CON_DEFAULT_NAND);
+}
+
+void *flash_swap_addr(unsigned long addr)
+{
+	return (void *)(addr ^ 2);
+}
diff --git a/arch/mips/cpu/mips32/vrx200/gphy.c b/arch/mips/cpu/mips32/vrx200/gphy.c
new file mode 100644
index 0000000000..54647ae14e
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/gphy.c
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <firmware.h>
+#include <asm/lantiq/io.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/gphy.h>
+
+static void ltq_fw_load(const char *name, ulong dst_addr)
+{
+	struct firmware fw;
+	int err;
+
+	err = request_firmware(&fw, name);
+	if (err)
+		return;
+
+	memcpy((void *) dst_addr, fw.data, fw.size);
+	flush_cache(dst_addr, fw.size);
+}
+
+void ltq_gphy_phy11g_a1x_load(ulong addr)
+{
+	ltq_fw_load("lantiq/vrx200_phy11g_a1x.fw", addr);
+}
+
+void ltq_gphy_phy11g_a2x_load(ulong addr)
+{
+	ltq_fw_load("lantiq/vrx200_phy11g_a2x.fw", addr);
+}
+
+void ltq_gphy_phy22f_a1x_load(ulong addr)
+{
+	ltq_fw_load("lantiq/vrx200_phy22f_a1x.fw", addr);
+}
+
+void ltq_gphy_phy22f_a2x_load(ulong addr)
+{
+	ltq_fw_load("lantiq/vrx200_phy22f_a2x.fw", addr);
+}
diff --git a/arch/mips/cpu/mips32/vrx200/mem.c b/arch/mips/cpu/mips32/vrx200/mem.c
new file mode 100644
index 0000000000..97c108d7e0
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/mem.c
@@ -0,0 +1,694 @@
+/*
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/soc.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/spl.h>
+#include <asm/lantiq/cpu.h>
+#include <asm/lantiq/mem.h>
+
+/* Must be configured in BOARDDIR */
+#include <ddr_settings.h>
+
+#if defined(CONFIG_SYS_DRAM_PROBE)
+#define mc_sdram_probe_enable		1
+#else
+#define mc_sdram_probe_enable		0
+#endif
+
+#define CCS_AHBM_CR_BURST_EN		(1 << 2)
+#define CCS_FPIM_CR_BURST_EN		(1 << 1)
+
+#define CCR03_EIGHT_BANK_MODE		(1 << 0)
+#define CCR07_START			(1 << 8)
+#define CCR08_CS_MAP_SHIFT		24
+#define CCR08_CS_MAP_MASK		(0x3 << CCR08_CS_MAP_SHIFT)
+#define CCR11_COLUMN_SIZE_SHIFT		24
+#define CCR11_COLUMN_SIZE_MASK		(0x7 << CCR11_COLUMN_SIZE_SHIFT)
+#define CCR11_COLUMN_SIZE_10		(2 << CCR11_COLUMN_SIZE_SHIFT)
+#define CCR11_ADDR_PINS_MASK		0x7
+#define CCR15_MAX_COL_REG_SHIFT		24
+#define CCR15_MAX_COL_REG_MASK		(0xF << CCR15_MAX_COL_REG_SHIFT)
+#define CCR16_MAX_ROW_REG_MASK		0xF
+#define CCR39_DLL_RD_DQ_DEL_NM_SHIFT	8
+#define CCR39_DLL_RD_DQ_DEL_NM_MASK	(0xFF << CCR43_DLL_WR_DQ_DEL_NM_SHIFT)
+#define CCR43_DLL_WR_DQ_DEL_NM_SHIFT	8
+#define CCR43_DLL_WR_DQ_DEL_NM_MASK	(0xFF << CCR43_DLL_WR_DQ_DEL_NM_SHIFT)
+#define CCR47_DLL_LOCK_IND		1
+
+#define DEFAULT_GATE_ECHO_DLL		0x24
+
+struct mc_global_regs {
+	u32 rsvd0[0x100];
+	u32 ddr_gsr0;		/* DDR SDRAM controller global status 0 */
+	u32 rsvd1;
+	u32 ddr_gcr0;		/* DDR SDRAM controller global control 0 */
+	u32 rsvd2;
+	u32 ddr_gcr1;		/* DDR SDRAM controller global control 1 */
+	u32 rsvd3;
+	u32 ddr_prio_ti;	/* DDR SDRAM controller priority of transaction initiator */
+	u32 rsvd4;
+	u32 ddr_echo_dll0;	/* DDR SDRAM controller echo gate DLL0 control */
+	u32 rsvd5;
+	u32 ddr_echo_dll1;	/* DDR SDRAM controller echo gate DLL1 control */
+	u32 rsvd6;
+	u32 ccs;		/* undocumented */
+};
+
+static struct mc_global_regs *mc_global_regs =
+	(void *) CKSEG1ADDR(LTQ_MC_GLOBAL_BASE);
+static void *mc_ddr_base = (void *) CKSEG1ADDR(LTQ_MC_DDR_BASE);
+static void *bootrom_base = (void *) CKSEG1ADDR(LTQ_BOOTROM_BASE);
+
+static __always_inline
+u32 mc_ccr_read(u32 index)
+{
+	return ltq_readl(mc_ddr_base + LTQ_MC_DDR_CCR_OFFSET(index));
+}
+
+static __always_inline
+void mc_ccr_write(u32 index, u32 val)
+{
+	ltq_writel(mc_ddr_base + LTQ_MC_DDR_CCR_OFFSET(index), val);
+}
+
+static __always_inline
+void mc_ccr_dump(u32 index)
+{
+	const void *addr = (void *)(mc_ddr_base +
+		LTQ_MC_DDR_CCR_OFFSET(index));
+	spl_debug("CCR%02u: 0x%p = 0x%08x\n", index, addr, ltq_readl(addr));
+}
+
+static __always_inline
+u32 bootrom_readl(u32 offset)
+{
+	return ltq_readl(bootrom_base + offset);
+}
+
+static __always_inline
+void bootrom_writel(u32 offset, u32 val)
+{
+	ltq_writel(bootrom_base + offset, val);
+}
+
+static __always_inline
+void mc_ddr_echo_dll_writel(unsigned int slice, unsigned int delay)
+{
+	if (slice)
+		ltq_writel(&mc_global_regs->ddr_echo_dll1, delay);
+	else
+		ltq_writel(&mc_global_regs->ddr_echo_dll0, delay);
+}
+
+static __always_inline
+void mc_halt(void)
+{
+	/*
+	 * Create multiple dummy accesses to ROM space to ensure the MIPS to
+	 * Xbar path is cleared of pending DDR SDRAM transactions.
+	 */
+	bootrom_writel(0, bootrom_readl(4));
+	bootrom_writel(4, bootrom_readl(8));
+	bootrom_writel(8, bootrom_readl(0));
+
+	/* Stop memory controller */
+	mc_ccr_write(7, MC_CCR07_VALUE & ~CCR07_START);
+}
+
+static __always_inline
+void mc_start(void)
+{
+	/* Start initialization sequence */
+	mc_ccr_write(7, MC_CCR07_VALUE | CCR07_START);
+
+	/* Wait until DLL0 has locked */
+	while (!(mc_ccr_read(47) & CCR47_DLL_LOCK_IND))
+		;
+
+	/* Wait until DLL1 has locked */
+	while (!(mc_ccr_read(48) & CCR47_DLL_LOCK_IND))
+		;
+}
+
+static __always_inline
+void mc_init(void)
+{
+	u32 ccr03 = MC_CCR03_VALUE;
+	u32 ccr11 = MC_CCR11_VALUE;
+
+	/*
+	 * Initial probe settings are 8-bank mode enabled, 14 use address
+	 * row bits, 10 used column address bits.
+	 */
+	if (mc_sdram_probe_enable) {
+		ccr03 |= CCR03_EIGHT_BANK_MODE;
+		ccr11 &= ~(CCR11_COLUMN_SIZE_MASK | CCR11_ADDR_PINS_MASK);
+		ccr11 |= CCR11_COLUMN_SIZE_10;
+	}
+
+	/* Init MC DDR CCR registers with values from ddr_settings.h */
+	mc_ccr_write(0, MC_CCR00_VALUE);
+	mc_ccr_write(1, MC_CCR01_VALUE);
+	mc_ccr_write(2, MC_CCR02_VALUE);
+	mc_ccr_write(3, ccr03);
+	mc_ccr_write(4, MC_CCR04_VALUE);
+	mc_ccr_write(5, MC_CCR05_VALUE);
+	mc_ccr_write(6, MC_CCR06_VALUE);
+	mc_ccr_write(8, MC_CCR08_VALUE);
+	mc_ccr_write(9, MC_CCR09_VALUE);
+
+	mc_ccr_write(10, MC_CCR10_VALUE);
+	mc_ccr_write(11, ccr11);
+	mc_ccr_write(12, MC_CCR12_VALUE);
+	mc_ccr_write(13, MC_CCR13_VALUE);
+	mc_ccr_write(14, MC_CCR14_VALUE);
+	mc_ccr_write(15, MC_CCR15_VALUE);
+	mc_ccr_write(16, MC_CCR16_VALUE);
+	mc_ccr_write(17, MC_CCR17_VALUE);
+	mc_ccr_write(18, MC_CCR18_VALUE);
+	mc_ccr_write(19, MC_CCR19_VALUE);
+
+	mc_ccr_write(20, MC_CCR20_VALUE);
+	mc_ccr_write(21, MC_CCR21_VALUE);
+	mc_ccr_write(22, MC_CCR22_VALUE);
+	mc_ccr_write(23, MC_CCR23_VALUE);
+	mc_ccr_write(24, MC_CCR24_VALUE);
+	mc_ccr_write(25, MC_CCR25_VALUE);
+	mc_ccr_write(26, MC_CCR26_VALUE);
+	mc_ccr_write(27, MC_CCR27_VALUE);
+	mc_ccr_write(28, MC_CCR28_VALUE);
+	mc_ccr_write(29, MC_CCR29_VALUE);
+
+	mc_ccr_write(30, MC_CCR30_VALUE);
+	mc_ccr_write(31, MC_CCR31_VALUE);
+	mc_ccr_write(32, MC_CCR32_VALUE);
+	mc_ccr_write(33, MC_CCR33_VALUE);
+	mc_ccr_write(34, MC_CCR34_VALUE);
+	mc_ccr_write(35, MC_CCR35_VALUE);
+	mc_ccr_write(36, MC_CCR36_VALUE);
+	mc_ccr_write(37, MC_CCR37_VALUE);
+	mc_ccr_write(38, MC_CCR38_VALUE);
+	mc_ccr_write(39, MC_CCR39_VALUE);
+
+	mc_ccr_write(40, MC_CCR40_VALUE);
+	mc_ccr_write(41, MC_CCR41_VALUE);
+	mc_ccr_write(42, MC_CCR42_VALUE);
+	mc_ccr_write(43, MC_CCR43_VALUE);
+	mc_ccr_write(44, MC_CCR44_VALUE);
+	mc_ccr_write(45, MC_CCR45_VALUE);
+	mc_ccr_write(46, MC_CCR46_VALUE);
+
+	mc_ccr_write(52, MC_CCR52_VALUE);
+	mc_ccr_write(53, MC_CCR53_VALUE);
+	mc_ccr_write(54, MC_CCR54_VALUE);
+	mc_ccr_write(55, MC_CCR55_VALUE);
+	mc_ccr_write(56, MC_CCR56_VALUE);
+	mc_ccr_write(57, MC_CCR57_VALUE);
+	mc_ccr_write(58, MC_CCR58_VALUE);
+	mc_ccr_write(59, MC_CCR59_VALUE);
+
+	mc_ccr_write(60, MC_CCR60_VALUE);
+	mc_ccr_write(61, MC_CCR61_VALUE);
+
+	/* Set initial values for gate echo DLL */
+	mc_ddr_echo_dll_writel(0, DEFAULT_GATE_ECHO_DLL);
+	mc_ddr_echo_dll_writel(1, DEFAULT_GATE_ECHO_DLL);
+
+	/* Disable bursts between FPI Master bus and XBAR bus */
+	ltq_writel(&mc_global_regs->ccs, CCS_AHBM_CR_BURST_EN);
+}
+
+static __always_inline
+void mc_sdram_probe(void)
+{
+	u32 ccr03 = MC_CCR03_VALUE;
+	u32 ccr11 = MC_CCR11_VALUE;
+	u32 val;
+
+	/*
+	 * Eight bank mode test:
+	 * - store a 1 at offset 0
+	 * - store a 0 at offset 2^13 (bit 2 in bank select address BA[3])
+	 * - load value at offset 0
+	 * - if that value is 0, the eight bank mode must be disabled
+	 */
+	sdram_uc_writel(0, 1);
+	sdram_uc_writel(1 << 13, 0);
+	val = sdram_uc_readl(0);
+	if (!val)
+		ccr03 &= ~CCR03_EIGHT_BANK_MODE;
+
+	/*
+	 * Row address test:
+	 * - store a 0 at offset 0
+	 * - store a 1 at offset 2^27 (bit 13 of row address RA[14])
+	 * - store a 2 at offset 2^26 (bit 12 of row address RA[14])
+	 * - load value at offset 0
+	 * - value indicates the useable row address bits
+	 */
+	sdram_uc_writel(0, 0);
+	sdram_uc_writel(1 << 27, 1);
+	sdram_uc_writel(1 << 26, 2);
+	val = sdram_uc_readl(0);
+	ccr11 += val;
+
+	/*
+	 * Column address test:
+	 * - store a 0 at offset 0
+	 * - store a 1 at offset 2^10 (bit 9 of column address CA[10])
+	 * - store a 2 at offset 2^9 (bit 8 of column address CA[10])
+	 * - load value at offset 0
+	 * - value indicates the useable column address bits
+	 */
+	sdram_uc_writel(0, 0);
+	sdram_uc_writel(1 << 10, 1);
+	sdram_uc_writel(1 << 9, 2);
+	val = sdram_uc_readl(0);
+	ccr11 += val << CCR11_COLUMN_SIZE_SHIFT;
+
+	mc_halt();
+	mc_ccr_write(3, ccr03);
+	mc_ccr_write(11, ccr11);
+	mc_start();
+}
+
+void ltq_mem_init(void)
+{
+	mc_halt();
+	mc_init();
+	mc_start();
+
+	if (mc_sdram_probe_enable)
+		mc_sdram_probe();
+}
+
+static phys_size_t mc_sdram_size(void)
+{
+	unsigned int max_col_reg, max_row_reg, column_size, addr_pins;
+	unsigned int banks, cs_map;
+	phys_size_t size;
+
+	banks = (mc_ccr_read(3) & CCR03_EIGHT_BANK_MODE) ? 8 : 4;
+
+	cs_map = (mc_ccr_read(8) & CCR08_CS_MAP_MASK) >>
+		CCR08_CS_MAP_SHIFT;
+
+	column_size = (mc_ccr_read(11) & CCR11_COLUMN_SIZE_MASK) >>
+		CCR11_COLUMN_SIZE_SHIFT;
+
+	addr_pins = mc_ccr_read(11) & CCR11_ADDR_PINS_MASK;
+
+	max_col_reg = (mc_ccr_read(15) & CCR15_MAX_COL_REG_MASK) >>
+		CCR15_MAX_COL_REG_SHIFT;
+
+	max_row_reg = mc_ccr_read(16) & CCR16_MAX_ROW_REG_MASK;
+
+	/*
+	 * size (bytes) = 2 ^ rowsize * 2 ^ colsize * banks * chipselects
+	 *                 * datawidth (bytes)
+	 */
+	size = (2 << (max_col_reg - column_size - 1)) *
+		(2 << (max_row_reg - addr_pins - 1)) * banks * cs_map * 2;
+
+	return size;
+}
+
+static void test_dump(const u8 *buf, unsigned int start, unsigned int stop)
+{
+	unsigned int i;
+
+	for (i = start; i < stop; i++) {
+		if (buf[i])
+			putc('1');
+		else
+			putc('0');
+
+		if (i % 16 == 15)
+			putc('\n');
+		else
+			putc(' ');
+	}
+}
+
+static __always_inline void mc_rd_dq_writel(unsigned int slice,
+						unsigned int delay)
+{
+	unsigned int offset = 39 + slice;
+	u32 val;
+
+	val = mc_ccr_read(offset);
+	val &= ~CCR39_DLL_RD_DQ_DEL_NM_MASK;
+	val |= delay << CCR39_DLL_RD_DQ_DEL_NM_SHIFT;
+	mc_ccr_write(offset, val);
+}
+
+static __always_inline void mc_wr_dq_writel(unsigned int slice,
+						unsigned int delay)
+{
+	unsigned int offset = 43 + slice;
+	u32 val;
+
+	val = mc_ccr_read(offset);
+	val &= ~CCR43_DLL_WR_DQ_DEL_NM_MASK;
+	val |= delay << CCR43_DLL_WR_DQ_DEL_NM_SHIFT;
+	mc_ccr_write(offset, val);
+}
+
+int mc_tune_perform(struct mc_tune_cfg *cfg)
+{
+	const phys_size_t sdram_size = mc_sdram_size();
+	const unsigned int read_max_q = 0x2b;
+	const unsigned int read_min_q = 0x15;
+	const unsigned int read_max = 0x3f;
+	const unsigned int read_min = 0x00;
+	const unsigned int write_q = 0x55;
+	const unsigned int write_max = 0x7f;
+	const unsigned int write_min = 0x40;
+	const unsigned int echo_dll_size = 0x80;
+	const unsigned int echo_dll_init = 0x20;
+	unsigned int i, dq;
+	unsigned int read_dq_l, read_dq_u, write_dq_l, write_dq_u;
+	unsigned int echo_dll_l, echo_dll_u;
+	unsigned int min_l, max_l, min_u, max_u;
+	u8 test_u[128], test_l[128];
+	int ret;
+
+#if 0
+	mc_ccr_dump(3);
+	mc_ccr_dump(11);
+	mc_ccr_dump(39);
+	mc_ccr_dump(40);
+	mc_ccr_dump(43);
+	mc_ccr_dump(44);
+	mc_ccr_dump(53);
+	mc_ccr_dump(54);
+#endif
+
+	mc_ddr_echo_dll_writel(0, echo_dll_init);
+	mc_ddr_echo_dll_writel(1, echo_dll_init);
+
+	/* initial read DQ delay tuning */
+	min_l = read_max_q;
+	max_l = read_min_q;
+	min_u = read_max_q;
+	max_u = read_min_q;
+
+	for (i = 0; i < 15; i++) {
+		mc_halt();
+		mc_wr_dq_writel(0, write_q + i);
+		mc_wr_dq_writel(1, write_q + i);
+
+		for (dq = read_min_q; dq < read_max_q; dq++) {
+			mc_halt();
+			mc_rd_dq_writel(0, dq);
+			mc_rd_dq_writel(1, dq);
+			mc_start();
+			__udelay(100);
+
+			ret = ltq_mem_test_tune(sdram_size, 0, 1);
+			if (ret == 0) {
+				if (min_l > dq)
+					min_l = dq;
+
+				if (max_l < dq)
+					max_l = dq;
+			}
+
+			ret = ltq_mem_test_tune(sdram_size, 1, 1);
+			if (ret == 0) {
+				if (min_u > dq)
+					min_u = dq;
+
+				if (max_u < dq)
+					max_u = dq;
+			}
+		}
+	}
+
+	if (max_l > min_l) {
+		read_dq_l = (min_l + max_l) >> 1;
+	} else {
+		spl_puts("MEM: failed to determine a suitable initial read DQS delay for slice #0\n");
+		goto err;
+	}
+
+	if (max_u > min_u) {
+		read_dq_u = (min_u + max_u) >> 1;
+	} else {
+		spl_puts("MEM: failed to determine a suitable initial read DQS delay for slice #1\n");
+		goto err;
+	}
+
+	/* gate echo DLL tuning */
+	min_l = echo_dll_size;
+	max_l = 0;
+	min_u = echo_dll_size;
+	max_u = 0;
+
+	if (spl_mc_tune_debug) {
+		memset(test_l, 0, sizeof(test_l));
+		memset(test_u, 0, sizeof(test_u));
+	}
+
+	for (i = 0; i < echo_dll_size; i++) {
+		mc_ddr_echo_dll_writel(0, i);
+		mc_ddr_echo_dll_writel(1, i);
+		cpu_sync();
+
+		ret = ltq_mem_test_tune(sdram_size, 0, 0);
+		if (ret == 0) {
+			if (min_l > i)
+				min_l = i;
+
+			if (max_l < i)
+				max_l = i;
+
+			if (spl_mc_tune_debug)
+				test_l[i] = 1;
+		}
+
+		ret = ltq_mem_test_tune(sdram_size, 1, 0);
+		if (ret == 0) {
+			if (min_u > i)
+				min_u = i;
+
+			if (max_u < i)
+				max_u = i;
+
+			if (spl_mc_tune_debug)
+				test_u[i] = 1;
+		}
+	}
+
+	if (max_l > min_l) {
+		echo_dll_l = (min_l + max_l) >> 1;
+	} else {
+		spl_puts("MEM: failed to determine a suitable echo DLL delay for slice #0\n");
+		goto err;
+	}
+
+	if (max_u > min_u) {
+		echo_dll_u = (min_u + max_u) >> 1;
+	} else {
+		spl_puts("MEM: failed to determine a suitable echo DLL delay for slice #1\n");
+		goto err;
+	}
+
+	if (spl_mc_tune_debug) {
+		printf("\nEcho DLL delay slice 0: %02x\n", echo_dll_l);
+		test_dump(test_l, 0, echo_dll_size);
+		printf("\nEcho DLL delay slice 1: %02x\n", echo_dll_u);
+		test_dump(test_u, 0, echo_dll_size);
+	}
+
+	mc_ddr_echo_dll_writel(0, echo_dll_l);
+	mc_ddr_echo_dll_writel(1, echo_dll_u);
+	cpu_sync();
+
+	/* write data eye tuning */
+	min_l = write_max;
+	max_l = write_min;
+	min_u = write_max;
+	max_u = write_min;
+
+	if (spl_mc_tune_debug) {
+		memset(test_l, 0, sizeof(test_l));
+		memset(test_u, 0, sizeof(test_u));
+	}
+
+	mc_halt();
+	mc_rd_dq_writel(0, read_dq_l);
+	mc_rd_dq_writel(1, read_dq_u);
+
+	for (dq = write_min; dq < write_max; dq++) {
+		mc_halt();
+		mc_wr_dq_writel(0, dq);
+		mc_wr_dq_writel(1, dq);
+		mc_start();
+		__udelay(100);
+
+		ret = ltq_mem_test_tune(sdram_size, 0, 0);
+		if (ret == 0) {
+			if (min_l > dq)
+				min_l = dq;
+
+			if (max_l < dq)
+				max_l = dq;
+
+			if (spl_mc_tune_debug)
+				test_l[dq] = 1;
+		}
+
+		ret = ltq_mem_test_tune(sdram_size, 1, 0);
+		if (ret == 0) {
+			if (min_u > dq)
+				min_u = dq;
+
+			if (max_u < dq)
+				max_u = dq;
+
+			if (spl_mc_tune_debug)
+				test_u[dq] = 1;
+		}
+	}
+
+	if (max_l > min_l) {
+		write_dq_l = (min_l + max_l) >> 1;
+	} else {
+		spl_puts("MEM: failed to determine a suitable write DQS delay for slice #0\n");
+		goto err;
+	}
+
+	if (max_u > min_u) {
+		write_dq_u = (min_u + max_u) >> 1;
+	} else {
+		spl_puts("MEM: failed to determine a suitable write DQS delay for slice #1\n");
+		goto err;
+	}
+
+	if (spl_mc_tune_debug) {
+		printf("\nWrite DQ delay slice 0: %02x\n", write_dq_l);
+		test_dump(test_l, write_min, write_max + 1);
+		printf("\nWrite DQ delay slice 1: %02x\n", write_dq_u);
+		test_dump(test_u, write_min, write_max + 1);
+	}
+
+	/* read data eye tuning */
+	min_l = read_max;
+	max_l = read_min;
+	min_u = read_max;
+	max_u = read_min;
+
+	if (spl_mc_tune_debug) {
+		memset(test_l, 0, sizeof(test_l));
+		memset(test_u, 0, sizeof(test_u));
+	}
+
+	mc_halt();
+	mc_wr_dq_writel(0, write_dq_l);
+	mc_wr_dq_writel(1, write_dq_u);
+
+	for (dq = read_min_q; dq < read_max_q; dq++) {
+		mc_halt();
+		mc_rd_dq_writel(0, dq);
+		mc_rd_dq_writel(1, dq);
+		mc_start();
+		__udelay(100);
+
+		ret = ltq_mem_test_tune(sdram_size, 0, 0);
+		if (ret == 0) {
+			if (min_l > dq)
+				min_l = dq;
+
+			if (max_l < dq)
+				max_l = dq;
+
+			if (spl_mc_tune_debug)
+				test_l[dq] = 1;
+		}
+
+		ret = ltq_mem_test_tune(sdram_size, 1, 0);
+		if (ret == 0) {
+			if (min_u > dq)
+				min_u = dq;
+
+			if (max_u < dq)
+				max_u = dq;
+
+			if (spl_mc_tune_debug)
+				test_u[dq] = 1;
+		}
+	}
+
+	if (max_l > min_l) {
+		read_dq_l = (min_l + max_l) >> 1;
+	} else {
+		spl_puts("MEM: failed to determine a suitable read DQS delay for slice #0\n");
+		goto err;
+	}
+
+	if (max_u > min_u) {
+		read_dq_u = (min_u + max_u) >> 1;
+	} else {
+		spl_puts("MEM: failed to determine a suitable read DQS delay for slice #1\n");
+		goto err;
+	}
+
+	if (spl_mc_tune_debug) {
+		printf("\nRead DQ delay slice 0: %02x\n", read_dq_l);
+		test_dump(test_l, read_min, read_max + 1);
+		printf("\nRead DQ delay slice 1: %02x\n", read_dq_u);
+		test_dump(test_u, read_min, read_max + 1);
+	}
+
+	mc_halt();
+	mc_rd_dq_writel(0, read_dq_l);
+	mc_rd_dq_writel(1, read_dq_u);
+	mc_start();
+
+	cfg->gate_echo_dll_l = echo_dll_l;
+	cfg->gate_echo_dll_u = echo_dll_u;
+	cfg->write_dqs_delay_l = write_dq_l;
+	cfg->write_dqs_delay_u = write_dq_u;
+	cfg->read_dqs_delay_l = read_dq_l;
+	cfg->read_dqs_delay_u = read_dq_u;
+	cfg->state = MC_TUNE_VALID;
+
+	return 0;
+
+err:
+	/* restore original values */
+	cfg->state = MC_TUNE_INVALID;
+	mc_halt();
+	mc_ccr_write(39, MC_CCR39_VALUE);
+	mc_ccr_write(40, MC_CCR40_VALUE);
+	mc_ccr_write(43, MC_CCR43_VALUE);
+	mc_ccr_write(44, MC_CCR44_VALUE);
+	mc_ddr_echo_dll_writel(0, DEFAULT_GATE_ECHO_DLL);
+	mc_ddr_echo_dll_writel(1, DEFAULT_GATE_ECHO_DLL);
+	mc_start();
+
+	return 1;
+}
+
+void mc_tune_apply(const struct mc_tune_cfg *cfg)
+{
+	mc_halt();
+	mc_ddr_echo_dll_writel(0, cfg->gate_echo_dll_l);
+	mc_ddr_echo_dll_writel(1, cfg->gate_echo_dll_u);
+	mc_wr_dq_writel(0, cfg->write_dqs_delay_l);
+	mc_wr_dq_writel(1, cfg->write_dqs_delay_u);
+	mc_rd_dq_writel(0, cfg->read_dqs_delay_l);
+	mc_rd_dq_writel(1, cfg->read_dqs_delay_u);
+	mc_start();
+}
+
+phys_size_t initdram(int board_type)
+{
+	return mc_sdram_size();
+}
diff --git a/arch/mips/cpu/mips32/vrx200/pmu.c b/arch/mips/cpu/mips32/vrx200/pmu.c
new file mode 100644
index 0000000000..a1444731a4
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/pmu.c
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/pm.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_PMU_PWDCR_RESERVED		((1 << 13) | (1 << 4))
+
+#define LTQ_PMU_PWDCR_PCIELOC_EN	(1 << 31)
+#define LTQ_PMU_PWDCR_GPHY		(1 << 30)
+#define LTQ_PMU_PWDCR_PPE_TOP		(1 << 29)
+#define LTQ_PMU_PWDCR_SWITCH		(1 << 28)
+#define LTQ_PMU_PWDCR_USB1		(1 << 27)
+#define LTQ_PMU_PWDCR_USB1_PHY		(1 << 26)
+#define LTQ_PMU_PWDCR_TDM		(1 << 25)
+#define LTQ_PMU_PWDCR_PPE_DPLUS		(1 << 24)
+#define LTQ_PMU_PWDCR_PPE_DPLUM		(1 << 23)
+#define LTQ_PMU_PWDCR_PPE_EMA		(1 << 22)
+#define LTQ_PMU_PWDCR_PPE_TC		(1 << 21)
+#define LTQ_PMU_PWDCR_DEU		(1 << 20)
+#define LTQ_PMU_PWDCR_PPE_SLL01		(1 << 19)
+#define LTQ_PMU_PWDCR_PPE_QSB		(1 << 18)
+#define LTQ_PMU_PWDCR_UART1		(1 << 17)
+#define LTQ_PMU_PWDCR_SDIO		(1 << 16)
+#define LTQ_PMU_PWDCR_AHBM		(1 << 15)
+#define LTQ_PMU_PWDCR_FPIM		(1 << 14)
+#define LTQ_PMU_PWDCR_GPTC		(1 << 12)
+#define LTQ_PMU_PWDCR_LEDC		(1 << 11)
+#define LTQ_PMU_PWDCR_EBU		(1 << 10)
+#define LTQ_PMU_PWDCR_DSL		(1 << 9)
+#define LTQ_PMU_PWDCR_SPI		(1 << 8)
+#define LTQ_PMU_PWDCR_USIF		(1 << 7)
+#define LTQ_PMU_PWDCR_USB0		(1 << 6)
+#define LTQ_PMU_PWDCR_DMA		(1 << 5)
+#define LTQ_PMU_PWDCR_DFEV1		(1 << 3)
+#define LTQ_PMU_PWDCR_DFEV0		(1 << 2)
+#define LTQ_PMU_PWDCR_FPIS		(1 << 1)
+#define LTQ_PMU_PWDCR_USB0_PHY		(1 << 0)
+
+struct ltq_pmu_regs {
+	u32	rsvd0[7];
+	u32	pwdcr;		/* Power down control */
+	u32	sr;		/* Power down status */
+	u32	pwdcr1;		/* Power down control 1 */
+	u32	sr1;		/* Power down status 1 */
+};
+
+static struct ltq_pmu_regs *ltq_pmu_regs =
+	(struct ltq_pmu_regs *) CKSEG1ADDR(LTQ_PMU_BASE);
+
+u32 ltq_pm_map(enum ltq_pm_modules module)
+{
+	u32 val;
+
+	switch (module) {
+	case LTQ_PM_CORE:
+		val = LTQ_PMU_PWDCR_UART1 | LTQ_PMU_PWDCR_FPIM |
+			LTQ_PMU_PWDCR_LEDC | LTQ_PMU_PWDCR_EBU;
+		break;
+	case LTQ_PM_DMA:
+		val = LTQ_PMU_PWDCR_DMA;
+		break;
+	case LTQ_PM_ETH:
+		val = LTQ_PMU_PWDCR_GPHY | LTQ_PMU_PWDCR_PPE_TOP |
+			LTQ_PMU_PWDCR_SWITCH | LTQ_PMU_PWDCR_PPE_DPLUS |
+			LTQ_PMU_PWDCR_PPE_DPLUM | LTQ_PMU_PWDCR_PPE_EMA |
+			LTQ_PMU_PWDCR_PPE_TC | LTQ_PMU_PWDCR_PPE_SLL01 |
+			LTQ_PMU_PWDCR_PPE_QSB;
+		break;
+	case LTQ_PM_SPI:
+		val = LTQ_PMU_PWDCR_SPI;
+		break;
+	default:
+		val = 0;
+		break;
+	}
+
+	return val;
+}
+
+int ltq_pm_enable(enum ltq_pm_modules module)
+{
+	const unsigned long timeout = 1000;
+	unsigned long timebase;
+	u32 sr, val;
+
+	val = ltq_pm_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_clrbits(&ltq_pmu_regs->pwdcr, val);
+
+	timebase = get_timer(0);
+
+	do {
+		sr = ltq_readl(&ltq_pmu_regs->sr);
+		if (~sr & val)
+			return 0;
+	} while (get_timer(timebase) < timeout);
+
+	return 1;
+}
+
+int ltq_pm_disable(enum ltq_pm_modules module)
+{
+	u32 val;
+
+	val = ltq_pm_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_setbits(&ltq_pmu_regs->pwdcr, val);
+
+	return 0;
+}
+
+void ltq_pmu_init(void)
+{
+	u32 set, clr;
+
+	clr = ltq_pm_map(LTQ_PM_CORE);
+	set = ~(LTQ_PMU_PWDCR_RESERVED | clr);
+
+	ltq_clrsetbits(&ltq_pmu_regs->pwdcr, clr, set);
+}
diff --git a/arch/mips/cpu/mips32/vrx200/rcu.c b/arch/mips/cpu/mips32/vrx200/rcu.c
new file mode 100644
index 0000000000..763f287c28
--- /dev/null
+++ b/arch/mips/cpu/mips32/vrx200/rcu.c
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/lantiq/io.h>
+#include <asm/lantiq/reset.h>
+#include <asm/lantiq/cpu.h>
+#include <asm/arch/soc.h>
+
+#define LTQ_RCU_RD_GPHY0	(1 << 31)	/* GPHY0 */
+#define LTQ_RCU_RD_SRST		(1 << 30)	/* Global SW Reset */
+#define LTQ_RCU_RD_GPHY1	(1 << 29)	/* GPHY1 */
+#define LTQ_RCU_RD_ENMIP2	(1 << 28)	/* Enable NMI of PLL2 */
+#define LTQ_RCU_RD_REG25_PD	(1 << 26)	/* Power down 2.5V regulator */
+#define LTQ_RCU_RD_ENDINIT	(1 << 25)	/* FPI slave bus access */
+#define LTQ_RCU_RD_PPE_ATM_TC	(1 << 23)	/* PPE ATM TC */
+#define LTQ_RCU_RD_PCIE		(1 << 22)	/* PCI-E core */
+#define LTQ_RCU_RD_ETHSW	(1 << 21)	/* Ethernet switch */
+#define LTQ_RCU_RD_DSP_DEN	(1 << 20)	/* Enable DSP JTAG */
+#define LTQ_RCU_RD_TDM		(1 << 19)	/* TDM module interface */
+#define LTQ_RCU_RD_ENMIP1	(1 << 18)	/* Enable NMI of PLL1 */
+#define LTQ_RCU_RD_SWBCK	(1 << 17)	/* Switch backward compat */
+#define LTQ_RCU_RD_HSNAND	(1 << 16)	/* HSNAND controller */
+#define LTQ_RCU_RD_ENMIP0	(1 << 15)	/* Enable NMI of PLL0 */
+#define LTQ_RCU_RD_MC		(1 << 14)	/* Memory Controller */
+#define LTQ_RCU_RD_PCI		(1 << 13)	/* PCI core */
+#define LTQ_RCU_RD_PCIE_PHY	(1 << 12)	/* PCI-E Phy */
+#define LTQ_RCU_RD_DFE_CORE	(1 << 11)	/* DFE core */
+#define LTQ_RCU_RD_SDIO		(1 << 10)	/* SDIO core */
+#define LTQ_RCU_RD_DMA		(1 << 9)	/* DMA core */
+#define LTQ_RCU_RD_PPE		(1 << 8)	/* PPE core */
+#define LTQ_RCU_RD_DFE		(1 << 7)	/* DFE core */
+#define LTQ_RCU_RD_AHB		(1 << 6)	/* AHB bus */
+#define LTQ_RCU_RD_HRST_CFG	(1 << 5)	/* HW reset configuration */
+#define LTQ_RCU_RD_USB		(1 << 4)	/* USB and Phy core */
+#define LTQ_RCU_RD_PPE_DSP	(1 << 3)	/* PPE DSP interface */
+#define LTQ_RCU_RD_FPI		(1 << 2)	/* FPI bus */
+#define LTQ_RCU_RD_CPU		(1 << 1)	/* CPU subsystem */
+#define LTQ_RCU_RD_HRST		(1 << 0)	/* HW reset via HRST pin */
+
+#define LTQ_RCU_STAT_BOOT_SHIFT		17
+#define LTQ_RCU_STAT_BOOT_MASK		(0xF << LTQ_RCU_STAT_BOOT_SHIFT)
+#define LTQ_RCU_STAT_BOOT_H		(1 << 12)
+
+#define LTQ_RCU_GP_STRAP_CLOCKSOURCE	(1 << 15)
+
+struct ltq_rcu_regs {
+	u32	rsvd0[4];
+	u32	req;		/* Reset request */
+	u32	stat;		/* Reset status */
+	u32	usb0_cfg;	/* USB0 configure */
+	u32	gp_strap;	/* GPIO strapping */
+	u32	gfs_add0;	/* GPHY0 firmware base addr */
+	u32	stat2;		/* SLIC and USB reset status */
+	u32	pci_rdy;	/* PCI boot ready */
+	u32	ppe_conf;	/* PPE ethernet config */
+	u32	pcie_phy_con;	/* PCIE PHY config/status */
+	u32	usb1_cfg;	/* USB1 configure */
+	u32	usb_ana_cfg1a;	/* USB analog config 1a */
+	u32	usb_ana_cfg1b;	/* USB analog config 1b */
+	u32	rsvd1;
+	u32	gf_mdio_add;	/* GPHY0/1 MDIO address */
+	u32	req2;		/* SLIC and USB reset request */
+	u32	ahb_endian;	/* AHB bus endianess */
+	u32	rsvd2[4];
+	u32	gcc;		/* General CPU config */
+	u32	rsvd3;
+	u32	gfs_add1;	/* GPHY1 firmware base addr */
+};
+
+static struct ltq_rcu_regs *ltq_rcu_regs =
+	(struct ltq_rcu_regs *) CKSEG1ADDR(LTQ_RCU_BASE);
+
+u32 ltq_reset_map(enum ltq_reset_modules module)
+{
+	u32 val;
+
+	switch (module) {
+	case LTQ_RESET_CORE:
+	case LTQ_RESET_SOFT:
+		val = LTQ_RCU_RD_SRST | LTQ_RCU_RD_CPU | LTQ_RCU_RD_ENMIP2 |
+			LTQ_RCU_RD_GPHY1 | LTQ_RCU_RD_GPHY0;
+		break;
+	case LTQ_RESET_DMA:
+		val = LTQ_RCU_RD_DMA;
+		break;
+	case LTQ_RESET_ETH:
+		val = LTQ_RCU_RD_PPE | LTQ_RCU_RD_ETHSW;
+		break;
+	case LTQ_RESET_PHY:
+		val = LTQ_RCU_RD_GPHY1 | LTQ_RCU_RD_GPHY0;
+		break;
+	case LTQ_RESET_HARD:
+		val = LTQ_RCU_RD_HRST;
+		break;
+	default:
+		val = 0;
+		break;
+	}
+
+	return val;
+}
+
+int ltq_reset_activate(enum ltq_reset_modules module)
+{
+	u32 val;
+
+	val = ltq_reset_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_setbits(&ltq_rcu_regs->req, val);
+
+	return 0;
+}
+
+int ltq_reset_deactivate(enum ltq_reset_modules module)
+{
+	u32 val;
+
+	val = ltq_reset_map(module);
+	if (unlikely(!val))
+		return 1;
+
+	ltq_clrbits(&ltq_rcu_regs->req, val);
+
+	return 0;
+}
+
+enum ltq_boot_select ltq_boot_select(void)
+{
+	u32 stat;
+	unsigned int bootstrap;
+
+	/*
+	 * Boot select value is built from bits 20-17 and bit 12.
+	 * The bit sequence is read as 4-2-1-0-3.
+	 */
+	stat = ltq_readl(&ltq_rcu_regs->stat);
+	bootstrap = ((stat & LTQ_RCU_STAT_BOOT_H) << 4) |
+		((stat & LTQ_RCU_STAT_BOOT_MASK) >> LTQ_RCU_STAT_BOOT_SHIFT);
+
+	switch (bootstrap) {
+	case 0:
+		return BOOT_NOR_NO_BOOTROM;
+	case 1:
+		return BOOT_RGMII1;
+	case 2:
+		return BOOT_NOR;
+	case 4:
+		return BOOT_UART_NO_EEPROM;
+	case 6:
+		return BOOT_PCI;
+	case 8:
+		return BOOT_UART;
+	case 10:
+		return BOOT_SPI;
+	case 12:
+		return BOOT_NAND;
+	default:
+		return BOOT_UNKNOWN;
+	}
+}
+
+void ltq_rcu_gphy_boot(unsigned int id, ulong addr)
+{
+	u32 module;
+	void *gfs_add;
+
+	switch (id) {
+	case 0:
+		module = LTQ_RCU_RD_GPHY0;
+		gfs_add = &ltq_rcu_regs->gfs_add0;
+		break;
+	case 1:
+		module = LTQ_RCU_RD_GPHY1;
+		gfs_add = &ltq_rcu_regs->gfs_add1;
+		break;
+	default:
+		BUG();
+	}
+
+	/* Stop and reset GPHY */
+	ltq_setbits(&ltq_rcu_regs->req, module);
+
+	/* Configure firmware and boot address */
+	ltq_writel(gfs_add, CPHYSADDR(addr & 0xFFFFC000));
+
+	/* Start GPHY by releasing reset */
+	ltq_clrbits(&ltq_rcu_regs->req, module);
+}
diff --git a/arch/mips/include/asm/arch-vrx200/config.h b/arch/mips/include/asm/arch-vrx200/config.h
new file mode 100644
index 0000000000..ba2f9a12a8
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/config.h
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Common board configuration for Lantiq XWAY VRX200 family
+ *
+ * Use following defines in your board config to enable specific features
+ * and drivers for this SoC:
+ *
+ * CONFIG_LTQ_SUPPORT_UART
+ * - support the VRX200 ASC/UART interface and console
+ *
+ * CONFIG_LTQ_SUPPORT_NOR_FLASH
+ * - support a parallel NOR flash via the CFI interface in flash bank 0
+ *
+ * CONFIG_LTQ_SUPPORT_ETHERNET
+ * - support the VRX200 internal switch
+ *
+ * CONFIG_LTQ_SUPPORT_SPI_FLASH
+ * - support the VRX200 SPI interface and serial flash drivers
+ * - specific SPI flash drivers must be configured separately
+ *
+ * CONFIG_LTQ_SUPPORT_SPL_SPI_FLASH
+ * - build a preloader that runs in the internal SRAM and loads
+ *   the U-Boot from SPI flash into RAM
+ */
+
+#ifndef __VRX200_CONFIG_H__
+#define __VRX200_CONFIG_H__
+
+/* CPU and SoC type */
+#define CONFIG_SOC_LANTIQ
+#define CONFIG_SOC_XWAY_VRX200
+
+/* Cache configuration */
+#define CONFIG_SYS_MIPS_CACHE_MODE	CONF_CM_CACHABLE_NONCOHERENT
+#define CONFIG_SYS_MIPS_CACHE_BASE	0x9fc00000
+#define CONFIG_SYS_MIPS_CACHE_INIT_RAM_LOAD
+
+#define CONFIG_SYS_MALLOC_LEN		4 * 1024 * 1024
+
+/*
+ * Supported clock modes
+ * PLL0 clock output is 1000 MHz
+ * PLL1 clock output is 393.219 MHz
+ */
+#define LTQ_CLK_CPU_600_DDR_300	0	/* Base PLL0, OCP 2 */
+#define LTQ_CLK_CPU_600_DDR_200	1	/* Base PLL0, OCP 3 */
+#define LTQ_CLK_CPU_500_DDR_250	2	/* Base PLL0, OCP 2 */
+#define LTQ_CLK_CPU_500_DDR_200	3	/* Base PLL0, OCP 2.5 */
+#define LTQ_CLK_CPU_333_DDR_167	4	/* Base PLL0, OCP 2 */
+#define LTQ_CLK_CPU_167_DDR_167	5	/* Base PLL0, OCP 1 */
+#define LTQ_CLK_CPU_125_DDR_125	6	/* Base PLL0, OCP 1 */
+#define LTQ_CLK_CPU_393_DDR_197	7	/* Base PLL1, OCP 2 */
+#define LTQ_CLK_CPU_197_DDR_197	8	/* Base PLL1, OCP 1 */
+
+/* CPU speed */
+#define CONFIG_SYS_CLOCK_MODE		LTQ_CLK_CPU_500_DDR_250
+#define CONFIG_SYS_HZ			1000
+
+/* RAM */
+#define CONFIG_SYS_SDRAM_BASE		0x80000000
+#define CONFIG_SYS_SDRAM_BASE_UC	0xa0000000
+#define CONFIG_SYS_MEMTEST_START	0x81000000
+#define CONFIG_SYS_MEMTEST_END		0x82000000
+#define CONFIG_SYS_LOAD_ADDR		0x81000000
+#define CONFIG_SYS_LOAD_SIZE		(2 * 1024 * 1024)
+#define CONFIG_SYS_INIT_SP_OFFSET	(32 * 1024)
+
+/* SRAM */
+#define CONFIG_SYS_SRAM_BASE		0xBE220000
+#define CONFIG_SYS_SRAM_SIZE		0x10000
+
+/* ASC/UART driver and console */
+#define CONFIG_LANTIQ_SERIAL
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* GPIO */
+#define CONFIG_LANTIQ_GPIO
+#define CONFIG_LTQ_GPIO_MAX_BANKS	3
+#define CONFIG_LTQ_HAS_GPIO_BANK3
+
+/* FLASH driver */
+#if defined(CONFIG_LTQ_SUPPORT_NOR_FLASH)
+#ifndef CONFIG_SYS_MAX_FLASH_BANKS
+#	define CONFIG_SYS_MAX_FLASH_BANKS	1
+#endif
+#define CONFIG_SYS_MAX_FLASH_SECT	256
+#define CONFIG_SYS_FLASH_BASE		0xB0000000
+#define CONFIG_FLASH_16BIT
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#define CONFIG_FLASH_SHOW_PROGRESS	50
+#define CONFIG_SYS_FLASH_PROTECTION
+#define CONFIG_CFI_FLASH_USE_WEAK_ADDR_SWAP
+
+#define CONFIG_CMD_FLASH
+#else
+#define CONFIG_SYS_NO_FLASH
+#endif /* CONFIG_NOR_FLASH */
+
+#if defined(CONFIG_LTQ_SUPPORT_SPI_FLASH)
+#define CONFIG_LANTIQ_SPI
+#define CONFIG_SPI_FLASH
+
+#define CONFIG_CMD_SF
+#define CONFIG_CMD_SPI
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_NAND_FLASH)
+#define CONFIG_NAND_LANTIQ
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+#define CONFIG_SYS_NAND_SELF_INIT
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE0		0xB0000000
+#define CONFIG_SYS_NAND_BASE1		0xB4000000
+
+#if defined(CONFIG_LTQ_NAND_CS0)
+#define CONFIG_SYS_NAND_BASE		(CONFIG_SYS_NAND_BASE0)
+#elif defined(CONFIG_LTQ_NAND_CS1)
+#define CONFIG_SYS_NAND_BASE		(CONFIG_SYS_NAND_BASE1)
+#else
+#error "invalid NAND configuration"
+#endif
+
+#define CONFIG_CMD_NAND
+#endif
+
+#if defined(CONFIG_LTQ_SUPPORT_ETHERNET)
+#define CONFIG_LANTIQ_DMA
+#define CONFIG_LANTIQ_VRX200_SWITCH
+#define CONFIG_PHY_LANTIQ
+
+#define CONFIG_SYS_RX_ETH_BUFFER	8
+#define CONFIG_PHYLIB
+#define CONFIG_MII
+#define CONFIG_UDP_CHECKSUM
+
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+
+#define CONFIG_FW_LOADER
+#endif
+
+#define CONFIG_SPL_MAX_SIZE		(32 * 1024)
+#define CONFIG_SPL_BSS_SIZE		(4 * 1024)
+#define CONFIG_SPL_STACK_SIZE		(4 * 1024)
+#define CONFIG_SPL_STACK_BASE		(CONFIG_SYS_SRAM_BASE + \
+					CONFIG_SPL_MAX_SIZE + \
+					CONFIG_SPL_STACK_SIZE - 1)
+#define CONFIG_SPL_BSS_BASE		(CONFIG_SPL_STACK_BASE + 1)
+
+#define CONFIG_SPL_MC_TUNE_BASE		(CONFIG_SYS_SDRAM_BASE_UC + \
+					CONFIG_SYS_INIT_SP_OFFSET)
+
+#if defined(CONFIG_SYS_BOOT_RAM)
+#define CONFIG_SYS_TEXT_BASE		0xA0100000
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_SYS_DISABLE_CACHE
+#endif
+
+#if defined(CONFIG_SYS_BOOT_NOR)
+#define CONFIG_SYS_TEXT_BASE		0xB0000000
+#endif
+
+#if defined(CONFIG_SYS_BOOT_SFSPL)
+#define CONFIG_SYS_TEXT_BASE		0x80100000
+#define CONFIG_SPL_TEXT_BASE		0xBE220000
+#endif
+
+#if defined(CONFIG_SYS_BOOT_NANDSPL)
+#define CONFIG_SYS_TEXT_BASE		0x80100000
+#if defined(CONFIG_TPL_BUILD)
+#define CONFIG_SPL_TEXT_BASE		0xBE220800
+#else
+#define CONFIG_SPL_TEXT_BASE		0xBE220000
+#endif
+#define CONFIG_TPL_TEXT_BASE		0xBE220800
+#endif
+
+#if defined(CONFIG_SYS_BOOT_NORSPL)
+#define CONFIG_SYS_TEXT_BASE		0x80100000
+#if defined(CONFIG_TPL_BUILD)
+#define CONFIG_SPL_TEXT_BASE		0xBE220000
+#else
+#define CONFIG_SPL_TEXT_BASE		0xB0000000
+#endif
+#define CONFIG_TPL_TEXT_BASE		0xBE220000
+#endif
+
+#if defined(CONFIG_SYS_BOOT_NOR) || defined(CONFIG_SYS_BOOT_NORSPL)
+#define CONFIG_SYS_XWAY_EBU_BOOTCFG	0x688C688C
+#define CONFIG_XWAY_SWAP_BYTES
+#endif
+
+#define	CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE
+
+#endif /* __VRX200_CONFIG_H__ */
diff --git a/arch/mips/include/asm/arch-vrx200/gphy.h b/arch/mips/include/asm/arch-vrx200/gphy.h
new file mode 100644
index 0000000000..6cdb26899c
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/gphy.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __VRX200_GPHY_H__
+#define __VRX200_GPHY_H__
+
+enum ltq_gphy_clk {
+	/* XTAL 36 MHz input */
+	LTQ_GPHY_CLK_36MHZ_XTAL = 1,
+	/* 25 MHz from PLL0 with divider */
+	LTQ_GPHY_CLK_25MHZ_PLL0 = 2,
+	/* derived from PLL2 output (XTAL is 36 MHz) */
+	LTQ_GPHY_CLK_24MHZ_PLL2 = 3,
+	/* 25 MHz Clock from Pin GPIO3 */
+	LTQ_GPHY_CLK_25MHZ_GPIO3 = 4,
+};
+
+/*
+ * Load PHY11G firmware for VRX200 v1.1 to given RAM address
+ *
+ * Address must be 16k aligned!
+ */
+extern void ltq_gphy_phy11g_a1x_load(ulong addr);
+
+/*
+ * Load PHY11G firmware for VRX200 v1.2 to given RAM address
+ *
+ * Address must be 16k aligned!
+ */
+extern void ltq_gphy_phy11g_a2x_load(ulong addr);
+
+/*
+ * Load PHY22F firmware for VRX200 v1.1 to given RAM address
+ *
+ * Address must be 16k aligned!
+ */
+extern void ltq_gphy_phy22f_a1x_load(ulong addr);
+
+/*
+ * Load PHY22F firmware for VRX200 v1.2 to given RAM address
+ *
+ * Address must be 16k aligned!
+ */
+extern void ltq_gphy_phy22f_a2x_load(ulong addr);
+
+/*
+ * Set clock source of internal GPHYs
+ *
+ * According registers resides in CGU address space. Thus this function
+ * is implemented by the CGU driver.
+ */
+extern void ltq_cgu_gphy_clk_src(enum ltq_gphy_clk clk);
+
+/*
+ * Boot internal GPHY with id from given RAM address
+ *
+ * According registers resides in RCU address space. Thus this function
+ * is implemented by the RCU driver.
+ */
+extern void ltq_rcu_gphy_boot(unsigned int id, ulong addr);
+
+#endif /* __VRX200_GPHY_H__ */
diff --git a/arch/mips/include/asm/arch-vrx200/gpio.h b/arch/mips/include/asm/arch-vrx200/gpio.h
new file mode 100644
index 0000000000..b8d7676509
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/gpio.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __VRX200_GPIO_H__
+#define __VRX200_GPIO_H__
+
+#include <asm/lantiq/gpio.h>
+
+#endif /* __VRX200_GPIO_H__ */
diff --git a/arch/mips/include/asm/arch-vrx200/soc.h b/arch/mips/include/asm/arch-vrx200/soc.h
new file mode 100644
index 0000000000..869bc91116
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/soc.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2010 Lantiq Deutschland GmbH
+ * Copyright (C) 2011-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __VRX200_SOC_H__
+#define __VRX200_SOC_H__
+
+#define LTQ_ASC0_BASE			0x1E100400
+#define LTQ_SPI_BASE			0x1E100800
+#define LTQ_GPIO_BASE			0x1E100B00
+#define LTQ_SSIO_BASE			0x1E100BB0
+#define LTQ_ASC1_BASE			0x1E100C00
+#define LTQ_DMA_BASE			0x1E104100
+
+#define LTQ_EBU_BASE			0x1E105300
+#define LTQ_EBU_REGION0_BASE		0x10000000
+#define LTQ_EBU_REGION1_BASE		0x14000000
+#define LTQ_EBU_NAND_BASE		(LTQ_EBU_BASE + 0xB0)
+
+#define LTQ_SWITCH_BASE			0x1E108000
+#define LTQ_SWITCH_CORE_BASE		LTQ_SWITCH_BASE
+#define LTQ_SWITCH_TOP_PDI_BASE		LTQ_SWITCH_CORE_BASE
+#define LTQ_SWITCH_BM_PDI_BASE		(LTQ_SWITCH_CORE_BASE + 4 * 0x40)
+#define LTQ_SWITCH_MAC_PDI_0_BASE	(LTQ_SWITCH_CORE_BASE + 4 * 0x900)
+#define LTQ_SWITCH_MAC_PDI_X_BASE(x)	(LTQ_SWITCH_MAC_PDI_0_BASE + x * 0x30)
+#define LTQ_SWITCH_TOPLEVEL_BASE	(LTQ_SWITCH_BASE + 4 * 0xC40)
+#define LTQ_SWITCH_MDIO_PDI_BASE	(LTQ_SWITCH_TOPLEVEL_BASE)
+#define LTQ_SWITCH_MII_PDI_BASE		(LTQ_SWITCH_TOPLEVEL_BASE + 4 * 0x36)
+#define LTQ_SWITCH_PMAC_PDI_BASE	(LTQ_SWITCH_TOPLEVEL_BASE + 4 * 0x82)
+
+#define LTQ_BOOTROM_BASE		0x1F000000
+#define LTQ_PMU_BASE			0x1F102000
+#define LTQ_CGU_BASE			0x1F103000
+#define LTQ_DCDC_BASE			0x1F106A00
+#define LTQ_MPS_BASE			0x1F107000
+#define LTQ_CHIPID_BASE			(LTQ_MPS_BASE + 0x340)
+#define LTQ_RCU_BASE			0x1F203000
+
+#define LTQ_MC_GLOBAL_BASE		0x1F400000
+#define LTQ_MC_DDR_BASE			0x1F401000
+#define LTQ_MC_DDR_CCR_OFFSET(x)	(x * 0x10)
+
+#endif /* __VRX200_SOC_H__ */
diff --git a/arch/mips/include/asm/arch-vrx200/switch.h b/arch/mips/include/asm/arch-vrx200/switch.h
new file mode 100644
index 0000000000..b1fd332f26
--- /dev/null
+++ b/arch/mips/include/asm/arch-vrx200/switch.h
@@ -0,0 +1,502 @@
+/*
+ *   Copyright (C) 2012-2013 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ *   SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __VRX200_SWITCH_H__
+#define __VRX200_SWITCH_H__
+
+/* Switch core registers */
+struct vr9_switch_core_regs {
+	u32 swres;		/* switch reset control */
+	/* TODO: implement registers */
+	u32 rsvd0[0x3f];
+};
+
+/* Switch buffer management registers */
+struct vr9_switch_bm_regs {
+	struct bm_core {
+		u32 ram_val3;	/* RAM value 3 */
+		u32 ram_val2;	/* RAM value 2 */
+		u32 ram_val1;	/* RAM value 1 */
+		u32 ram_val0;	/* RAM value 0 */
+		u32 ram_addr;	/* RAM address */
+		u32 ram_ctrl;	/* RAM access control */
+		u32 fsqm_gctrl;	/* Free segment queue global control */
+		u32 cons_sel;	/* Number of consumed segments */
+		u32 cons_pkt;	/* Number of consumed packet pointers */
+		u32 gctrl;	/* Global control */
+		u32 queue_gctrl;/* Queue manager global control */
+		/* TODO: implement registers */
+		u32 rsvd0[0x35];
+	} core;
+
+	struct bm_port {
+		u32 pcfg;	/* Port config */
+		u32 rmon_ctrl;	/* RMON control */
+	} port[13];
+
+	u32 rsvd0[0x66];
+
+	struct bm_queue {
+		u32 rsvd0;
+		u32 pqm_rs;	/* Packet queue manager rate shape assignment */
+	} queue[32];
+
+	struct bm_shaper {
+		u32 ctrl;	/* Rate shaper control */
+		u32 cbs;	/* Rate shaper committed burst size */
+		u32 ibs;	/* Rate shaper instantaneous burst size */
+		u32 cir_ext;	/* Rate shaper rate exponent */
+		u32 cir_mant;	/* Rate shaper rate mantissa */
+	} shaper[16];
+
+	u32 rsvd1[0x2a8];
+};
+
+/* Switch parser and classification engine registers */
+struct vr9_switch_pce_regs {
+	struct pce_core {
+		u32 tbl_key[16];/* Table key data */
+		u32 tbl_mask;	/* Table mask */
+		u32 tbl_val[5];	/* Table value */
+		u32 tbl_addr;	/* Table entry address */
+		u32 tbl_ctrl;	/* Table access control */
+		u32 tbl_stat;	/* Table general status */
+		u32 age_0;	/* Aging counter config 0 */
+		u32 age_1;	/* Aging counter config 1 */
+		u32 pmap_1;	/* Port map (monitoring) */
+		u32 pmap_2;	/* Port map (multicast) */
+		u32 pmap_3;	/* Port map (unknown unicast) */
+		u32 gctrl_0;	/* Global control 0 */
+		u32 gctrl_1;	/* Global control 1 */
+		u32 tcm_gctrl;	/* Three-color marker global control */
+		u32 igmp_ctrl;	/* IGMP control */
+		u32 igmp_drpm;	/* IGMP default router port map */
+		u32 igmp_age_0;	/* IGMP aging 0 */
+		u32 igmp_age_1;	/* IGMP aging 1 */
+		u32 igmp_stat;	/* IGMP status */
+		u32 wol_gctrl;	/* Wake-on-LAN control */
+		u32 wol_da_0;	/* Wake-on-LAN destination address 0 */
+		u32 wol_da_1;	/* Wake-on-LAN destination address 1 */
+		u32 wol_da_2;	/* Wake-on-LAN destination address 2 */
+		u32 wol_pw_0;	/* Wake-on-LAN password 0 */
+		u32 wol_pw_1;	/* Wake-on-LAN password 1 */
+		u32 wol_pw_2;	/* Wake-on-LAN password 2 */
+		u32 ier_0;	/* PCE global interrupt enable 0 */
+		u32 ier_1;	/* PCE global interrupt enable 1 */
+		u32 isr_0;	/* PCE global interrupt status 0 */
+		u32 isr_1;	/* PCE global interrupt status 1 */
+		u32 parser_stat;/* Parser status */
+		u32 rsvd0[0x6];
+	} core;
+
+	u32 rsvd0[0x10];
+
+	struct pce_port {
+		u32 pctrl_0;	/* Port control 0 */
+		u32 pctrl_1;	/* Port control 1 */
+		u32 pctrl_2;	/* Port control 2 */
+		u32 pctrl_3;	/* Port control 3 */
+		u32 wol_ctrl;	/* Wake-on-LAN control */
+		u32 vlan_ctrl;	/* VLAN control */
+		u32 def_pvid;	/* Default port VID */
+		u32 pstat;	/* Port status */
+		u32 pier;	/* Interrupt enable */
+		u32 pisr;	/* Interrupt status */
+	} port[13];
+
+	u32 rsvd1[0x7e];
+
+	struct pce_meter {
+		/* TODO: implement registers */
+		u32 rsvd0[0x7];
+	} meter[8];
+
+	u32 rsvd2[0x308];
+};
+
+static inline unsigned int to_pce_tbl_key_id(unsigned int id)
+{
+	BUG_ON(id > 15);
+
+	return 15 - id;
+}
+
+static inline unsigned int to_pce_tbl_value_id(unsigned int id)
+{
+	BUG_ON(id > 4);
+
+	return 4 - id;
+}
+
+/* Switch ethernet MAC registers */
+struct vr9_switch_mac_regs {
+	struct mac_core {
+		u32 test;		/* MAC test */
+		u32 pfad_cfg;		/* Pause frame source address config */
+		u32 pfsa_0;		/* Pause frame source address 0 */
+		u32 pfsa_1;		/* Pause frame source address 1 */
+		u32 pfsa_2;		/* Pause frame source address 2 */
+		u32 flen;		/* Frame length */
+		u32 vlan_etype_0;	/* VLAN ethertype 0 */
+		u32 vlan_etype_1;	/* VLAN ethertype 1 */
+		u32 ier;		/* Interrupt enable */
+		u32 isr;		/* Interrupt status */
+		u32 rsvd0[0x36];
+	} core;
+
+	struct mac_port {
+		u32 pstat;		/* Port status */
+		u32 pisr;		/* Interrupt status */
+		u32 pier;		/* Interrupt enable */
+		u32 ctrl_0;		/* Control 0 */
+		u32 ctrl_1;		/* Control 1 */
+		u32 ctrl_2;		/* Control 2 */
+		u32 ctrl_3;		/* Control 3 */
+		u32 ctrl_4;		/* Control 4 */
+		u32 ctrl_5;		/* Control 5 */
+		u32 rsvd0[0x2];
+		u32 testen;		/* Test enable */
+	} port[13];
+
+	u32 rsvd0[0xa4];
+};
+
+/* Switch Fetch DMA registers */
+struct vr9_switch_fdma_regs {
+	struct fdma_core {
+		u32 ctrl;		/* FDMA control */
+		u32 stetype;		/* Special tag ethertype control */
+		u32 vtetype;		/* VLAN tag ethertype control */
+		u32 stat;		/* FDMA status */
+		u32 ier;		/* FDMA interrupt enable */
+		u32 isr;		/* FDMA interrupt status */
+	} core;
+
+	u32 rsvd0[0x3a];
+
+	struct fdma_port {
+		u32 pctrl;		/* Port control */
+		u32 prio;		/* Port priority */
+		u32 pstat_0;		/* Port status 0 */
+		u32 pstat_1;		/* Port status 1 */
+		u32 tstamp_0;		/* Egress time stamp 0 */
+		u32 tstamp_1;		/* Egress time stamp 1 */
+	} port[13];
+
+	u32 rsvd1[0x72];
+};
+
+/* Switch Store DMA registers */
+struct vr9_switch_sdma_regs {
+	struct sdma_core {
+		u32 ctrl;		/* SDMA Control */
+		u32 fcthr_1;		/* Flow control threshold 1 */
+		u32 rsvd0;
+		u32 fcthr_3;		/* Flow control threshold 3 */
+		u32 fcthr_4;		/* Flow control threshold 4 */
+		u32 fcthr_5;		/* Flow control threshold 5 */
+		u32 fcthr_6;		/* Flow control threshold 6 */
+		u32 fcthr_7;		/* Flow control threshold 7 */
+		u32 stat_0;		/* SDMA status 0 */
+		u32 stat_1;		/* SDMA status 1 */
+		u32 stat_2;		/* SDMA status 2 */
+		u32 ier;		/* SDMA interrupt enable */
+		u32 isr;		/* SDMA interrupt status */
+	} core;
+
+	u32 rsvd0[0x73];
+
+	struct sdma_port {
+		u32 pctrl;		/* Port control */
+		u32 prio;		/* Port priority */
+		u32 pstat_0;		/* Port status 0 */
+		u32 pstat_1;		/* Port status 1 */
+		u32 tstamp_0;		/* Ingress time stamp 0 */
+		u32 tstamp_1;		/* Ingress time stamp 1 */
+	} port[13];
+
+	u32 rsvd1[0x32];
+};
+
+/* Switch MDIO control and status registers */
+struct vr9_switch_mdio_regs {
+	u32 glob_ctrl;		/* Global control 0 */
+	u32 rsvd0[7];
+	u32 mdio_ctrl;		/* MDIO control */
+	u32 mdio_read;		/* MDIO read data */
+	u32 mdio_write;		/* MDIO write data */
+	u32 mdc_cfg_0;		/* MDC clock configuration 0 */
+	u32 mdc_cfg_1;		/* MDC clock configuration 1 */
+	u32 rsvd1[0x3];
+	u32 phy_addr[6];	/* PHY address port 5..0 */
+	u32 mdio_stat[6];	/* MDIO PHY polling status port 0..5 */
+	u32 aneg_eee[6];	/* EEE auto-neg overrides port 0..5 */
+	u32 rsvd2[0x14];
+};
+
+static inline unsigned int to_mdio_phyaddr_id(unsigned int id)
+{
+	BUG_ON(id > 5);
+
+	return 5 - id;
+}
+
+/* Switch xMII control registers */
+struct vr9_switch_mii_regs {
+	u32 mii_cfg0;		/* xMII port 0 configuration */
+	u32 pcdu0;		/* Port 0 clock delay configuration */
+	u32 mii_cfg1;		/* xMII port 1 configuration */
+	u32 pcdu1;		/* Port 1 clock delay configuration */
+	u32 rsvd0[0x6];
+	u32 mii_cfg5;		/* xMII port 5 configuration */
+	u32 pcdu5;		/* Port 5 clock delay configuration */
+	u32 rsvd1[0x14];
+	u32 rxb_ctl_0;		/* Port 0 receive buffer control */
+	u32 rxb_ctl_1;		/* Port 1 receive buffer control */
+	u32 rxb_ctl_5;		/* Port 5 receive buffer control */
+	u32 rsvd2[0x28];
+	u32 dbg_ctl;		/* Debug control */
+};
+
+/* Switch Pseudo-MAC registers */
+struct vr9_switch_pmac_regs {
+	u32 hd_ctl;		/* PMAC header control */
+	u32 tl;			/* PMAC type/length */
+	u32 sa1;		/* PMAC source address 1 */
+	u32 sa2;		/* PMAC source address 2 */
+	u32 sa3;		/* PMAC source address 3 */
+	u32 da1;		/* PMAC destination address 1 */
+	u32 da2;		/* PMAC destination address 2 */
+	u32 da3;		/* PMAC destination address 3 */
+	u32 vlan;		/* PMAC VLAN */
+	u32 rx_ipg;		/* PMAC interpacket gap in RX direction */
+	u32 st_etype;		/* PMAC special tag ethertype */
+	u32 ewan;		/* PMAC ethernet WAN group */
+	u32 ctl;		/* PMAC control */
+	u32 rsvd0[0x2];
+};
+
+struct vr9_switch_regs {
+	struct vr9_switch_core_regs core;
+	struct vr9_switch_bm_regs bm;
+	struct vr9_switch_pce_regs pce;
+	struct vr9_switch_mac_regs mac;
+	struct vr9_switch_fdma_regs fdma;
+	struct vr9_switch_sdma_regs sdma;
+	struct vr9_switch_mdio_regs mdio;
+	struct vr9_switch_mii_regs mii;
+	struct vr9_switch_pmac_regs pmac;
+};
+
+static inline void *to_pce_tbl_key(struct vr9_switch_regs *regs,
+						unsigned int id)
+{
+	return &regs->pce.core.tbl_key[to_pce_tbl_key_id(id)];
+}
+
+static inline void *to_pce_tbl_value(struct vr9_switch_regs *regs,
+						unsigned int id)
+{
+	return &regs->pce.core.tbl_val[to_pce_tbl_value_id(id)];
+}
+
+static inline void *to_mac_ctrl(struct vr9_switch_regs *regs,
+					unsigned int id, unsigned int ctrl)
+{
+	struct mac_port *mac = &regs->mac.port[id];
+
+	switch (ctrl) {
+	case 0:
+		return &mac->ctrl_0;
+	case 1:
+		return &mac->ctrl_1;
+	case 2:
+		return &mac->ctrl_2;
+	case 3:
+		return &mac->ctrl_3;
+	case 4:
+		return &mac->ctrl_4;
+	case 5:
+		return &mac->ctrl_5;
+	default:
+		return NULL;
+	}
+}
+
+static inline void *to_mdio_phyaddr(struct vr9_switch_regs *regs,
+					unsigned int id)
+{
+	return &regs->mdio.phy_addr[to_mdio_phyaddr_id(id)];
+}
+
+static inline void *to_mii_miicfg(struct vr9_switch_regs *regs,
+					unsigned int id)
+{
+	switch (id) {
+	case 0:
+		return &regs->mii.mii_cfg0;
+	case 1:
+		return &regs->mii.mii_cfg1;
+	case 5:
+		return &regs->mii.mii_cfg5;
+	default:
+		return NULL;
+	}
+}
+
+static inline void *to_mii_pcdu(struct vr9_switch_regs *regs,
+					unsigned int id)
+{
+	switch (id) {
+	case 0:
+		return &regs->mii.pcdu0;
+	case 1:
+		return &regs->mii.pcdu1;
+	case 5:
+		return &regs->mii.pcdu5;
+	default:
+		return NULL;
+	}
+}
+
+#define VR9_SWITCH_REG_OFFSET(reg)	(4 * (reg))
+
+#define BUILD_CHECK_VR9_REG(name, offset)	\
+	BUILD_BUG_ON(offsetof(struct vr9_switch_regs, name) != (4 * offset))
+
+static inline void build_check_vr9_registers(void)
+{
+	BUILD_CHECK_VR9_REG(core, 0x0);
+	BUILD_CHECK_VR9_REG(bm.core, 0x40);
+	BUILD_CHECK_VR9_REG(bm.core.queue_gctrl, 0x4a);
+	BUILD_CHECK_VR9_REG(bm.port[0], 0x80);
+	BUILD_CHECK_VR9_REG(bm.queue, 0x100);
+	BUILD_CHECK_VR9_REG(bm.shaper, 0x140);
+	BUILD_CHECK_VR9_REG(pce.core, 0x438);
+	BUILD_CHECK_VR9_REG(pce.core.tbl_ctrl, 0x44f);
+	BUILD_CHECK_VR9_REG(pce.core.parser_stat, 0x469);
+	BUILD_CHECK_VR9_REG(pce.port[0], 0x480);
+	BUILD_CHECK_VR9_REG(pce.meter[0], 0x580);
+	BUILD_CHECK_VR9_REG(mac.core, 0x8c0);
+	BUILD_CHECK_VR9_REG(mac.port[0].pstat, 0x900);
+	BUILD_CHECK_VR9_REG(mac.port[0].ctrl_0, 0x903);
+	BUILD_CHECK_VR9_REG(mac.port[1].pstat, 0x90c);
+	BUILD_CHECK_VR9_REG(mac.port[1].ctrl_0, 0x90f);
+	BUILD_CHECK_VR9_REG(mac.port[2].pstat, 0x918);
+	BUILD_CHECK_VR9_REG(mac.port[2].ctrl_0, 0x91b);
+	BUILD_CHECK_VR9_REG(fdma.core, 0xa40);
+	BUILD_CHECK_VR9_REG(fdma.port[0], 0xa80);
+	BUILD_CHECK_VR9_REG(sdma.core, 0xb40);
+	BUILD_CHECK_VR9_REG(sdma.port[0], 0xbc0);
+	BUILD_CHECK_VR9_REG(mdio, 0xc40);
+	BUILD_CHECK_VR9_REG(mii, (0xc40 + 0x36));
+	BUILD_CHECK_VR9_REG(pmac, (0xc40 + 0x82));
+}
+
+#define BM_GCTRL_F_SRES		1
+
+#define MAC_CTRL0_BM		(1 << 12)
+#define MAC_CTRL0_APADEN	(1 << 11)
+#define MAC_CTRL0_VPAD2EN	(1 << 10)
+#define MAC_CTRL0_VPADEN	(1 << 9)
+#define MAC_CTRL0_PADEN		(1 << 8)
+#define MAC_CTRL0_FCS		(1 << 7)
+#define MAC_CTRL0_FCON_SHIFT	4
+#define MAC_CTRL0_FCON_AUTO	(0x0 << MAC_CTRL0_FCON_SHIFT)
+#define MAC_CTRL0_FCON_RX	(0x1 << MAC_CTRL0_FCON_SHIFT)
+#define MAC_CTRL0_FCON_TX	(0x2 << MAC_CTRL0_FCON_SHIFT)
+#define MAC_CTRL0_FCON_RXTX	(0x3 << MAC_CTRL0_FCON_SHIFT)
+#define MAC_CTRL0_FCON_NONE	(0x4 << MAC_CTRL0_FCON_SHIFT)
+#define MAC_CTRL0_FDUP_SHIFT	2
+#define MAC_CTRL0_FDUP_AUTO	(0x0 << MAC_CTRL0_FDUP_SHIFT)
+#define MAC_CTRL0_FDUP_EN	(0x1 << MAC_CTRL0_FDUP_SHIFT)
+#define MAC_CTRL0_FDUP_DIS	(0x3 << MAC_CTRL0_FDUP_SHIFT)
+#define MAC_CTRL0_GMII_AUTO	0x0
+#define MAC_CTRL0_GMII_MII	0x1
+#define MAC_CTRL0_GMII_GMII	0x2
+#define MAC_CTRL0_GMII_GMII_2G	0x3
+
+#define MAC_CTRL1_DEFERMODE	(1 << 15)
+#define MAC_CTRL1_SHORTPRE	(1 << 8)
+
+#define MAC_CTRL2_MLEN		(1 << 3)
+#define MAC_CTRL2_LCHKL		(1 << 2)
+#define MAC_CTRL2_LCHKS_DIS	0x0
+#define MAC_CTRL2_LCHKS_UNTAG	0x1
+#define MAC_CTRL2_LCHKS_TAG	0x2
+
+#define PHY_ADDR_LNKST_SHIFT	13
+#define PHY_ADDR_LNKST_AUTO	(0x0 << PHY_ADDR_LNKST_SHIFT)
+#define PHY_ADDR_LNKST_UP	(0x1 << PHY_ADDR_LNKST_SHIFT)
+#define PHY_ADDR_LNKST_DOWN	(0x2 << PHY_ADDR_LNKST_SHIFT)
+#define PHY_ADDR_SPEED_SHIFT	11
+#define PHY_ADDR_SPEED_M10	(0x0 << PHY_ADDR_SPEED_SHIFT)
+#define PHY_ADDR_SPEED_M100	(0x1 << PHY_ADDR_SPEED_SHIFT)
+#define PHY_ADDR_SPEED_G1	(0x2 << PHY_ADDR_SPEED_SHIFT)
+#define PHY_ADDR_SPEED_AUTO	(0x3 << PHY_ADDR_SPEED_SHIFT)
+#define PHY_ADDR_FDUP_SHIFT	9
+#define PHY_ADDR_FDUP_AUTO	(0x0 << PHY_ADDR_FDUP_SHIFT)
+#define PHY_ADDR_FDUP_EN	(0x1 << PHY_ADDR_FDUP_SHIFT)
+#define PHY_ADDR_FDUP_DIS	(0x3 << PHY_ADDR_FDUP_SHIFT)
+#define PHY_ADDR_FCONTX_SHIFT	7
+#define PHY_ADDR_FCONTX_AUTO	(0x0 << PHY_ADDR_FCONTX_SHIFT)
+#define PHY_ADDR_FCONTX_EN	(0x1 << PHY_ADDR_FCONTX_SHIFT)
+#define PHY_ADDR_FCONTX_DIS	(0x3 << PHY_ADDR_FCONTX_SHIFT)
+#define PHY_ADDR_FCONRX_SHIFT	5
+#define PHY_ADDR_FCONRX_AUTO	(0x0 << PHY_ADDR_FCONRX_SHIFT)
+#define PHY_ADDR_FCONRX_EN	(0x1 << PHY_ADDR_FCONRX_SHIFT)
+#define PHY_ADDR_FCONRX_DIS	(0x3 << PHY_ADDR_FCONRX_SHIFT)
+
+#define MII_CFG_RES		(1 << 15)
+#define MII_CFG_EN		(1 << 14)
+#define MII_CFG_LDCLKDIS	(1 << 12)
+#define MII_CFG_MIIRATE_SHIFT	4
+#define MII_CFG_MIIRATE_MASK	(0x7 << MII_CFG_MIIRATE_SHIFT)
+#define MII_CFG_MIIRATE_M2P5	(0x0 << MII_CFG_MIIRATE_SHIFT)
+#define MII_CFG_MIIRATE_M25	(0x1 << MII_CFG_MIIRATE_SHIFT)
+#define MII_CFG_MIIRATE_M125	(0x2 << MII_CFG_MIIRATE_SHIFT)
+#define MII_CFG_MIIRATE_M50	(0x3 << MII_CFG_MIIRATE_SHIFT)
+#define MII_CFG_MIIRATE_AUTO	(0x4 << MII_CFG_MIIRATE_SHIFT)
+#define MII_CFG_MIIMODE_MASK	0xf
+#define MII_CFG_MIIMODE_MIIP	0x0
+#define MII_CFG_MIIMODE_MIIM	0x1
+#define MII_CFG_MIIMODE_RMIIP	0x2
+#define MII_CFG_MIIMODE_RMIIM	0x3
+#define MII_CFG_MIIMODE_RGMII	0x4
+
+#define PCDU_RXDLY_SHIFT	7
+#define PCDU_RXDLY_MASK		(0x7 << PCDU_RXDLY_SHIFT)
+#define PCDU_TXDLY_MASK		0x7
+
+#define PMAC_HD_CTL_FC		(1 << 10)
+#define PMAC_HD_CTL_CCRC	(1 << 9)
+#define PMAC_HD_CTL_RST		(1 << 8)
+#define PMAC_HD_CTL_AST		(1 << 7)
+#define PMAC_HD_CTL_RXSH	(1 << 6)
+#define PMAC_HD_CTL_RC		(1 << 4)
+#define PMAC_HD_CTL_AS		(1 << 3)
+#define PMAC_HD_CTL_AC		(1 << 2)
+
+#define PCE_PCTRL_0_IGSTEN	(1 << 11)
+
+#define FDMA_PCTRL_STEN		(1 << 1)
+#define FDMA_PCTRL_EN		(1 << 0)
+
+#define SDMA_PCTRL_EN		(1 << 0)
+
+#define MDIO_GLOB_CTRL_SE	(1 << 15)
+
+#define MDIO_MDC_CFG1_RES	(1 << 15)
+#define MDIO_MDC_CFG1_MCEN	(1 << 8)
+
+#define MDIO_CTRL_MBUSY		(1 << 12)
+#define MDIO_CTRL_OP_READ	(1 << 11)
+#define MDIO_CTRL_OP_WRITE	(1 << 10)
+#define MDIO_CTRL_PHYAD_SHIFT	5
+#define MDIO_CTRL_PHYAD_MASK	(0x1f << MDIO_CTRL_PHYAD_SHIFT)
+#define MDIO_CTRL_REGAD_MASK	0x1f
+
+#endif /* __VRX200_SWITCH_H__ */
-- 
2.11.0

