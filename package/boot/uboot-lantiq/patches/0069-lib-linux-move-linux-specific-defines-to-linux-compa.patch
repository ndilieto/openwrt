From 7b4c22846731863239e9ff5929759f8ec52c89de Mon Sep 17 00:00:00 2001
From: Heiko Schocher <hs@denx.de>
Date: Tue, 24 Jun 2014 10:10:03 +0200
Subject: [PATCH 069/158] lib, linux: move linux specific defines to
 linux/compat.h

- move linux specific defines from usb and video code
  into linux/compat.h
- move common linux specific defines from include/ubi_uboot.h
  to linux/compat.h
- add for new mtd/ubi/ubifs sync new needed linux specific
  defines to linux/compat.h

Signed-off-by: Heiko Schocher <hs@denx.de>
Cc: Marek Vasut <marex@denx.de>
Cc: Anatolij Gustschin <agust@denx.de>
[trini: Add spin_lock_irqsave/spin_unlock_irqrestore dummies from
usb/lin_gadet_compat.h]
Signed-off-by: Tom Rini <trini@ti.com>
---
 drivers/usb/gadget/ether.c          |   5 -
 drivers/usb/gadget/storage_common.c |   5 -
 drivers/usb/musb-new/linux-compat.h |  58 ------
 drivers/video/exynos_dp.c           |   1 +
 drivers/video/exynos_mipi_dsi.c     |   1 +
 fs/yaffs2/ydirectenv.h              |   2 -
 include/linux/compat.h              | 348 +++++++++++++++++++++++++++++++++++-
 include/linux/usb/gadget.h          |   6 +-
 include/ubi_uboot.h                 | 165 ++---------------
 lib/Makefile                        |   1 +
 lib/linux_compat.c                  |  47 +++++
 11 files changed, 404 insertions(+), 235 deletions(-)
 create mode 100644 lib/linux_compat.c

diff --git a/drivers/usb/gadget/ether.c b/drivers/usb/gadget/ether.c
index cc6cc1f32a..d0dd29ffb2 100644
--- a/drivers/usb/gadget/ether.c
+++ b/drivers/usb/gadget/ether.c
@@ -25,15 +25,10 @@
 
 #define atomic_read
 extern struct platform_data brd;
-#define spin_lock(x)
-#define spin_unlock(x)
 
 
 unsigned packet_received, packet_sent;
 
-#define GFP_ATOMIC ((gfp_t) 0)
-#define GFP_KERNEL ((gfp_t) 0)
-
 /*
  * Ethernet gadget driver -- with CDC and non-CDC options
  * Builds on hardware support for a full duplex link.
diff --git a/drivers/usb/gadget/storage_common.c b/drivers/usb/gadget/storage_common.c
index 02803df23c..b55e40bbda 100644
--- a/drivers/usb/gadget/storage_common.c
+++ b/drivers/usb/gadget/storage_common.c
@@ -267,11 +267,6 @@ struct interrupt_data {
 #define ASCQ(x)		((u8) (x))
 
 struct device_attribute { int i; };
-struct rw_semaphore { int i; };
-#define down_write(...)			do { } while (0)
-#define up_write(...)			do { } while (0)
-#define down_read(...)			do { } while (0)
-#define up_read(...)			do { } while (0)
 #define ETOOSMALL	525
 
 #include <usb_mass_storage.h>
diff --git a/drivers/usb/musb-new/linux-compat.h b/drivers/usb/musb-new/linux-compat.h
index d7a5663deb..46f83d9b36 100644
--- a/drivers/usb/musb-new/linux-compat.h
+++ b/drivers/usb/musb-new/linux-compat.h
@@ -5,39 +5,6 @@
 #include <linux/list.h>
 #include <linux/compat.h>
 
-#define __init
-#define __devinit
-#define __devinitdata
-#define __devinitconst
-#define __iomem
-#define __deprecated
-
-struct unused {};
-typedef struct unused unused_t;
-
-typedef int irqreturn_t;
-typedef unused_t spinlock_t;
-
-struct work_struct {};
-
-struct timer_list {};
-struct notifier_block {};
-
-typedef unsigned long dmaaddr_t;
-
-#define spin_lock_init(lock) do {} while (0)
-#define spin_lock(lock) do {} while (0)
-#define spin_unlock(lock) do {} while (0)
-#define spin_lock_irqsave(lock, flags) do {} while (0)
-#define spin_unlock_irqrestore(lock, flags) do {} while (0)
-
-#define setup_timer(timer, func, data) do {} while (0)
-#define del_timer_sync(timer) do {} while (0)
-#define schedule_work(work) do {} while (0)
-#define INIT_WORK(work, fun) do {} while (0)
-
-#define cpu_relax() do {} while (0)
-
 #define pr_debug(fmt, args...) debug(fmt, ##args)
 
 #define WARN(condition, fmt, args...) ({	\
@@ -46,21 +13,6 @@ typedef unsigned long dmaaddr_t;
 		printf(fmt, ##args);		\
 	ret_warn; })
 
-#define pm_runtime_get_sync(dev) do {} while (0)
-#define pm_runtime_put(dev) do {} while (0)
-#define pm_runtime_put_sync(dev) do {} while (0)
-#define pm_runtime_use_autosuspend(dev) do {} while (0)
-#define pm_runtime_set_autosuspend_delay(dev, delay) do {} while (0)
-#define pm_runtime_enable(dev) do {} while (0)
-
-#define MODULE_DESCRIPTION(desc)
-#define MODULE_AUTHOR(author)
-#define MODULE_LICENSE(license)
-#define MODULE_ALIAS(alias)
-#define module_param(name, type, perm)
-#define MODULE_PARM_DESC(name, desc)
-#define EXPORT_SYMBOL_GPL(name)
-
 #define writesl(a, d, s) __raw_writesl((unsigned long)a, d, s)
 #define readsl(a, d, s) __raw_readsl((unsigned long)a, d, s)
 #define writesw(a, d, s) __raw_writesw((unsigned long)a, d, s)
@@ -68,16 +20,6 @@ typedef unsigned long dmaaddr_t;
 #define writesb(a, d, s) __raw_writesb((unsigned long)a, d, s)
 #define readsb(a, d, s) __raw_readsb((unsigned long)a, d, s)
 
-#define IRQ_NONE 0
-#define IRQ_HANDLED 0
-
-#define dev_set_drvdata(dev, data) do {} while (0)
-
-#define disable_irq_wake(irq) do {} while (0)
-#define enable_irq_wake(irq) -EINVAL
-#define free_irq(irq, data) do {} while (0)
-#define request_irq(nr, f, flags, nm, data) 0
-
 #define device_init_wakeup(dev, a) do {} while (0)
 
 #define platform_data device_data
diff --git a/drivers/video/exynos_dp.c b/drivers/video/exynos_dp.c
index 682483fc32..f60b060ec1 100644
--- a/drivers/video/exynos_dp.c
+++ b/drivers/video/exynos_dp.c
@@ -9,6 +9,7 @@
 #include <config.h>
 #include <common.h>
 #include <malloc.h>
+#include <linux/compat.h>
 #include <linux/err.h>
 #include <asm/arch/clk.h>
 #include <asm/arch/cpu.h>
diff --git a/drivers/video/exynos_mipi_dsi.c b/drivers/video/exynos_mipi_dsi.c
index 7dd4652931..c68ebd6f7b 100644
--- a/drivers/video/exynos_mipi_dsi.c
+++ b/drivers/video/exynos_mipi_dsi.c
@@ -11,6 +11,7 @@
 #include <malloc.h>
 #include <fdtdec.h>
 #include <libfdt.h>
+#include <linux/compat.h>
 #include <linux/err.h>
 #include <asm/arch/dsim.h>
 #include <asm/arch/mipi_dsim.h>
diff --git a/fs/yaffs2/ydirectenv.h b/fs/yaffs2/ydirectenv.h
index c6614f13b0..2b3e84fd38 100644
--- a/fs/yaffs2/ydirectenv.h
+++ b/fs/yaffs2/ydirectenv.h
@@ -58,8 +58,6 @@ void yaffs_qsort(void *aa, size_t n, size_t es,
 #define inline
 #endif
 
-#define cond_resched()  do {} while (0)
-
 #define yaffs_trace(msk, fmt, ...) do { \
 	if (yaffs_trace_mask & (msk)) \
 		printf("yaffs: " fmt "\n", ##__VA_ARGS__); \
diff --git a/include/linux/compat.h b/include/linux/compat.h
index 3fdfb399b5..7ff6064b18 100644
--- a/include/linux/compat.h
+++ b/include/linux/compat.h
@@ -1,6 +1,19 @@
 #ifndef _LINUX_COMPAT_H_
 #define _LINUX_COMPAT_H_
 
+#include <malloc.h>
+#include <linux/types.h>
+#include <linux/err.h>
+
+struct unused {};
+typedef struct unused unused_t;
+
+struct p_current{
+       int pid;
+};
+
+extern struct p_current *current;
+
 #define ndelay(x)	udelay(1)
 
 #define dev_dbg(dev, fmt, args...)		\
@@ -12,6 +25,7 @@
 #define dev_err(dev, fmt, args...)		\
 	printf(fmt, ##args)
 #define printk	printf
+#define printk_once	printf
 
 #define KERN_EMERG
 #define KERN_ALERT
@@ -22,11 +36,20 @@
 #define KERN_INFO
 #define KERN_DEBUG
 
-#define kmalloc(size, flags)	malloc(size)
-#define kzalloc(size, flags)	calloc(size, 1)
-#define vmalloc(size)		malloc(size)
-#define kfree(ptr)		free(ptr)
-#define vfree(ptr)		free(ptr)
+void *kmalloc(size_t size, int flags);
+void *kzalloc(size_t size, int flags);
+#define vmalloc(size)	kmalloc(size, 0)
+#define __vmalloc(size, flags, pgsz)	kmalloc(size, flags)
+#define kfree(ptr)	free(ptr)
+#define vfree(ptr)	free(ptr)
+
+struct kmem_cache { int sz; };
+
+struct kmem_cache *get_mem(int element_sz);
+#define kmem_cache_create(a, sz, c, d, e)	get_mem(sz)
+void *kmem_cache_alloc(struct kmem_cache *obj, int flag);
+#define kmem_cache_free(obj, size)	free(size)
+#define kmem_cache_destroy(obj)		free(obj)
 
 #define DECLARE_WAITQUEUE(...)	do { } while (0)
 #define add_wait_queue(...)	do { } while (0)
@@ -57,4 +80,319 @@
 				  , __FILE__, __LINE__); }
 
 #define PAGE_SIZE	4096
+
+/**
+ * upper_32_bits - return MSB bits 32-63 of a number if little endian, or
+ * return MSB bits 0-31 of a number if big endian.
+ * @n: the number we're accessing
+ *
+ * A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress
+ * the "right shift count >= width of type" warning when that quantity is
+ * 32-bits.
+ */
+#define upper_32_bits(n) ((u32)(((n) >> 16) >> 16))
+
+/**
+ * lower_32_bits - return LSB bits 0-31 of a number if little endian, or
+ * return LSB bits 32-63 of a number if big endian.
+ * @n: the number we're accessing
+ */
+#define lower_32_bits(n) ((u32)(n))
+
+/* drivers/char/random.c */
+#define get_random_bytes(...)
+
+/* idr.c */
+#define GFP_ATOMIC ((gfp_t) 0)
+#define GFP_KERNEL ((gfp_t) 0)
+#define GFP_NOFS ((gfp_t) 0)
+#define GFP_USER ((gfp_t) 0)
+#define __GFP_NOWARN ((gfp_t) 0)
+
+/* include/linux/leds.h */
+struct led_trigger {};
+
+#define DEFINE_LED_TRIGGER(x)		static struct led_trigger *x;
+enum led_brightness {
+	LED_OFF		= 0,
+	LED_HALF	= 127,
+	LED_FULL	= 255,
+};
+
+static inline void led_trigger_register_simple(const char *name,
+					struct led_trigger **trigger) {}
+static inline void led_trigger_unregister_simple(struct led_trigger *trigger) {}
+static inline void led_trigger_event(struct led_trigger *trigger,
+					enum led_brightness event) {}
+
+/* include/linux/log2.h */
+static inline int is_power_of_2(unsigned long n)
+{
+	return (n != 0 && ((n & (n - 1)) == 0));
+}
+
+/* uapi/linux/limits.h */
+#define XATTR_LIST_MAX 65536	/* size of extended attribute namelist (64k) */
+
+/**
+ * The type used for indexing onto a disc or disc partition.
+ *
+ * Linux always considers sectors to be 512 bytes long independently
+ * of the devices real block size.
+ *
+ * blkcnt_t is the type of the inode's block count.
+ */
+#ifdef CONFIG_LBDAF
+typedef u64 sector_t;
+typedef u64 blkcnt_t;
+#else
+typedef unsigned long sector_t;
+typedef unsigned long blkcnt_t;
+#endif
+
+#define ENOTSUPP	524	/* Operation is not supported */
+
+/* from include/linux/kernel.h */
+/*
+ * This looks more complex than it should be. But we need to
+ * get the type for the ~ right in round_down (it needs to be
+ * as wide as the result!), and we want to evaluate the macro
+ * arguments just once each.
+ */
+#define __round_mask(x, y) ((__typeof__(x))((y)-1))
+#define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1)
+#define round_down(x, y) ((x) & ~__round_mask(x, y))
+
+/* module */
+#define THIS_MODULE		0
+#define try_module_get(...)	1
+#define module_put(...)		do { } while (0)
+#define module_init(...)
+#define module_exit(...)
+#define EXPORT_SYMBOL(...)
+#define EXPORT_SYMBOL_GPL(...)
+#define module_param(...)
+#define module_param_call(...)
+#define MODULE_PARM_DESC(...)
+#define MODULE_VERSION(...)
+#define MODULE_DESCRIPTION(...)
+#define MODULE_AUTHOR(...)
+#define MODULE_LICENSE(...)
+#define MODULE_ALIAS(...)
+#define __module_get(...)
+
+/* character device */
+#define MKDEV(...)			0
+#define MAJOR(dev)			0
+#define MINOR(dev)			0
+
+#define alloc_chrdev_region(...)	0
+#define unregister_chrdev_region(...)
+
+#define class_create(...)		__builtin_return_address(0)
+#define class_create_file(...)		0
+#define class_remove_file(...)
+#define class_destroy(...)
+#define misc_register(...)		0
+#define misc_deregister(...)
+
+#define blocking_notifier_call_chain(...) 0
+
+/*
+ * Multiplies an integer by a fraction, while avoiding unnecessary
+ * overflow or loss of precision.
+ */
+#define mult_frac(x, numer, denom)(			\
+{							\
+	typeof(x) quot = (x) / (denom);			\
+	typeof(x) rem  = (x) % (denom);			\
+	(quot * (numer)) + ((rem * (numer)) / (denom));	\
+}							\
+)
+
+#define __initdata
+#define late_initcall(...)
+
+#define dev_set_name(...)		do { } while (0)
+#define device_register(...)		0
+#define volume_sysfs_init(...)		0
+#define volume_sysfs_close(...)		do { } while (0)
+
+#define init_waitqueue_head(...)	do { } while (0)
+#define wait_event_interruptible(...)	0
+#define wake_up_interruptible(...)	do { } while (0)
+#define print_hex_dump(...)		do { } while (0)
+#define dump_stack(...)			do { } while (0)
+
+#define task_pid_nr(x)			0
+#define set_freezable(...)		do { } while (0)
+#define try_to_freeze(...)		0
+#define set_current_state(...)		do { } while (0)
+#define kthread_should_stop(...)	0
+#define schedule()			do { } while (0)
+
+#define setup_timer(timer, func, data) do {} while (0)
+#define del_timer_sync(timer) do {} while (0)
+#define schedule_work(work) do {} while (0)
+#define INIT_WORK(work, fun) do {} while (0)
+
+struct work_struct {};
+
+unsigned long copy_from_user(void *dest, const void *src,
+			     unsigned long count);
+
+void *vzalloc(unsigned long size);
+
+typedef unused_t spinlock_t;
+typedef int	wait_queue_head_t;
+
+#define spin_lock_init(lock) do {} while (0)
+#define spin_lock(lock) do {} while (0)
+#define spin_unlock(lock) do {} while (0)
+#define spin_lock_irqsave(lock, flags) do { debug("%lu\n", flags); } while (0)
+#define spin_unlock_irqrestore(lock, flags) do { flags = 0; } while (0)
+
+#define DEFINE_MUTEX(...)
+#define mutex_init(...)
+#define mutex_lock(...)
+#define mutex_unlock(...)
+
+#define init_rwsem(...)			do { } while (0)
+#define down_read(...)			do { } while (0)
+#define down_write(...)			do { } while (0)
+#define down_write_trylock(...)		1
+#define up_read(...)			do { } while (0)
+#define up_write(...)			do { } while (0)
+
+#define cond_resched()			do { } while (0)
+#define yield()				do { } while (0)
+
+#define INT_MAX				((int)(~0U>>1))
+
+#define __user
+#define __init
+#define __exit
+#define __devinit
+#define __devinitdata
+#define __devinitconst
+#define __iomem
+
+#define kthread_create(...)	__builtin_return_address(0)
+#define kthread_stop(...)	do { } while (0)
+#define wake_up_process(...)	do { } while (0)
+
+struct rw_semaphore { int i; };
+#define down_write(...)			do { } while (0)
+#define up_write(...)			do { } while (0)
+#define down_read(...)			do { } while (0)
+#define up_read(...)			do { } while (0)
+struct device {
+	struct device		*parent;
+	struct class		*class;
+	dev_t			devt;	/* dev_t, creates the sysfs "dev" */
+	void	(*release)(struct device *dev);
+	/* This is used from drivers/usb/musb-new subsystem only */
+	void		*driver_data;	/* data private to the driver */
+	void            *device_data;   /* data private to the device */
+};
+struct mutex { int i; };
+struct kernel_param { int i; };
+
+struct cdev {
+	int owner;
+	dev_t dev;
+};
+#define cdev_init(...)		do { } while (0)
+#define cdev_add(...)		0
+#define cdev_del(...)		do { } while (0)
+
+#define MAX_ERRNO		4095
+
+#define prandom_u32(...)	0
+
+typedef struct {
+	uid_t val;
+} kuid_t;
+
+typedef struct {
+	gid_t val;
+} kgid_t;
+
+/* from include/linux/types.h */
+
+typedef int	atomic_t;
+/**
+ * struct callback_head - callback structure for use with RCU and task_work
+ * @next: next update requests in a list
+ * @func: actual update function to call after the grace period.
+ */
+struct callback_head {
+	struct callback_head *next;
+	void (*func)(struct callback_head *head);
+};
+#define rcu_head callback_head
+enum writeback_sync_modes {
+	WB_SYNC_NONE,	/* Don't wait on anything */
+	WB_SYNC_ALL,	/* Wait on every mapping */
+};
+
+/* from include/linux/writeback.h */
+/*
+ * A control structure which tells the writeback code what to do.  These are
+ * always on the stack, and hence need no locking.  They are always initialised
+ * in a manner such that unspecified fields are set to zero.
+ */
+struct writeback_control {
+	long nr_to_write;		/* Write this many pages, and decrement
+					   this for each page written */
+	long pages_skipped;		/* Pages which were not written */
+
+	/*
+	 * For a_ops->writepages(): if start or end are non-zero then this is
+	 * a hint that the filesystem need only write out the pages inside that
+	 * byterange.  The byte at `end' is included in the writeout request.
+	 */
+	loff_t range_start;
+	loff_t range_end;
+
+	enum writeback_sync_modes sync_mode;
+
+	unsigned for_kupdate:1;		/* A kupdate writeback */
+	unsigned for_background:1;	/* A background writeback */
+	unsigned tagged_writepages:1;	/* tag-and-write to avoid livelock */
+	unsigned for_reclaim:1;		/* Invoked from the page allocator */
+	unsigned range_cyclic:1;	/* range_start is cyclic */
+	unsigned for_sync:1;		/* sync(2) WB_SYNC_ALL writeback */
+};
+
+void *kmemdup(const void *src, size_t len, gfp_t gfp);
+
+typedef int irqreturn_t;
+
+struct timer_list {};
+struct notifier_block {};
+
+typedef unsigned long dmaaddr_t;
+
+#define cpu_relax() do {} while (0)
+
+#define pm_runtime_get_sync(dev) do {} while (0)
+#define pm_runtime_put(dev) do {} while (0)
+#define pm_runtime_put_sync(dev) do {} while (0)
+#define pm_runtime_use_autosuspend(dev) do {} while (0)
+#define pm_runtime_set_autosuspend_delay(dev, delay) do {} while (0)
+#define pm_runtime_enable(dev) do {} while (0)
+
+#define IRQ_NONE 0
+#define IRQ_HANDLED 1
+
+#define dev_set_drvdata(dev, data) do {} while (0)
+
+#define enable_irq(...)
+#define disable_irq(...)
+#define disable_irq_wake(irq) do {} while (0)
+#define enable_irq_wake(irq) -EINVAL
+#define free_irq(irq, data) do {} while (0)
+#define request_irq(nr, f, flags, nm, data) 0
+
 #endif
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index a8a576316d..9bccd451af 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -19,6 +19,7 @@
 #define __LINUX_USB_GADGET_H
 
 #include <errno.h>
+#include <linux/compat.h>
 #include <linux/list.h>
 
 struct usb_ep;
@@ -410,11 +411,6 @@ struct usb_gadget_ops {
 				unsigned code, unsigned long param);
 };
 
-struct device {
-	void		*driver_data;	/* data private to the driver */
-	void            *device_data;   /* data private to the device */
-};
-
 /**
  * struct usb_gadget - represents a usb slave device
  * @ops: Function pointers used to access hardware-specific operations.
diff --git a/include/ubi_uboot.h b/include/ubi_uboot.h
index 7f720229a6..1fd15f43e4 100644
--- a/include/ubi_uboot.h
+++ b/include/ubi_uboot.h
@@ -16,8 +16,10 @@
 
 #include <common.h>
 #include <compiler.h>
+#include <linux/compat.h>
 #include <malloc.h>
 #include <div64.h>
+#include <linux/math64.h>
 #include <linux/crc32.h>
 #include <linux/types.h>
 #include <linux/list.h>
@@ -32,15 +34,11 @@
 
 #include <asm/errno.h>
 
-#define DPRINTK(format, args...)					\
-do {									\
-	printf("%s[%d]: " format "\n", __func__, __LINE__, ##args);	\
-} while (0)
-
 /* configurable */
+#if !defined(CONFIG_MTD_UBI_WL_THRESHOLD)
 #define CONFIG_MTD_UBI_WL_THRESHOLD	4096
+#endif
 #define CONFIG_MTD_UBI_BEB_RESERVE	1
-#define UBI_IO_DEBUG			0
 
 /* debug options (Linux: drivers/mtd/ubi/Kconfig.debug) */
 #undef CONFIG_MTD_UBI_DEBUG
@@ -50,161 +48,18 @@ do {									\
 #undef CONFIG_MTD_UBI_DEBUG_MSG_WL
 #undef CONFIG_MTD_UBI_DEBUG_MSG_IO
 #undef CONFIG_MTD_UBI_DEBUG_MSG_BLD
-#define CONFIG_MTD_UBI_DEBUG_DISABLE_BGT
+
+#undef CONFIG_MTD_UBI_BLOCK
+
+#if !defined(CONFIG_MTD_UBI_BEB_LIMIT)
+#define CONFIG_MTD_UBI_BEB_LIMIT	20
+#endif
 
 /* build.c */
 #define get_device(...)
 #define put_device(...)
 #define ubi_sysfs_init(...)		0
 #define ubi_sysfs_close(...)		do { } while (0)
-static inline int is_power_of_2(unsigned long n)
-{
-	return (n != 0 && ((n & (n - 1)) == 0));
-}
-
-/* FIXME */
-#define MKDEV(...)			0
-#define MAJOR(dev)			0
-#define MINOR(dev)			0
-
-#define alloc_chrdev_region(...)	0
-#define unregister_chrdev_region(...)
-
-#define class_create(...)		__builtin_return_address(0)
-#define class_create_file(...)		0
-#define class_remove_file(...)
-#define class_destroy(...)
-#define misc_register(...)		0
-#define misc_deregister(...)
-
-/* vmt.c */
-#define device_register(...)		0
-#define volume_sysfs_init(...)		0
-#define volume_sysfs_close(...)		do { } while (0)
-
-/* kapi.c */
-
-/* eba.c */
-
-/* io.c */
-#define init_waitqueue_head(...)	do { } while (0)
-#define wait_event_interruptible(...)	0
-#define wake_up_interruptible(...)	do { } while (0)
-#define print_hex_dump(...)		do { } while (0)
-#define dump_stack(...)			do { } while (0)
-
-/* wl.c */
-#define task_pid_nr(x)			0
-#define set_freezable(...)		do { } while (0)
-#define try_to_freeze(...)		0
-#define set_current_state(...)		do { } while (0)
-#define kthread_should_stop(...)	0
-#define schedule()			do { } while (0)
-
-/* upd.c */
-static inline unsigned long copy_from_user(void *dest, const void *src,
-					   unsigned long count)
-{
-	memcpy((void *)dest, (void *)src, count);
-	return 0;
-}
-
-/* common */
-typedef int	spinlock_t;
-typedef int	wait_queue_head_t;
-#define spin_lock_init(...)
-#define spin_lock(...)
-#define spin_unlock(...)
-
-#define mutex_init(...)
-#define mutex_lock(...)
-#define mutex_unlock(...)
-
-#define init_rwsem(...)			do { } while (0)
-#define down_read(...)			do { } while (0)
-#define down_write(...)			do { } while (0)
-#define down_write_trylock(...)		1
-#define up_read(...)			do { } while (0)
-#define up_write(...)			do { } while (0)
-
-struct kmem_cache { int i; };
-#define kmem_cache_create(...)		1
-#define kmem_cache_alloc(obj, gfp)	malloc(sizeof(struct ubi_wl_entry))
-#define kmem_cache_free(obj, size)	free(size)
-#define kmem_cache_destroy(...)
-
-#define cond_resched()			do { } while (0)
-#define yield()				do { } while (0)
-
-#define KERN_WARNING
-#define KERN_ERR
-#define KERN_NOTICE
-#define KERN_DEBUG
-
-#define GFP_KERNEL			0
-#define GFP_NOFS			1
-
-#define __user
-#define __init
-#define __exit
-
-#define kthread_create(...)	__builtin_return_address(0)
-#define kthread_stop(...)	do { } while (0)
-#define wake_up_process(...)	do { } while (0)
-
-#define BUS_ID_SIZE		20
-
-struct rw_semaphore { int i; };
-struct device {
-	struct device		*parent;
-	struct class		*class;
-	char	bus_id[BUS_ID_SIZE];	/* position on parent bus */
-	dev_t			devt;	/* dev_t, creates the sysfs "dev" */
-	void	(*release)(struct device *dev);
-};
-struct mutex { int i; };
-struct kernel_param { int i; };
-
-struct cdev {
-	int owner;
-	dev_t dev;
-};
-#define cdev_init(...)		do { } while (0)
-#define cdev_add(...)		0
-#define cdev_del(...)		do { } while (0)
-
-#define MAX_ERRNO		4095
-#define IS_ERR_VALUE(x)		((x) >= (unsigned long)-MAX_ERRNO)
-
-static inline void *ERR_PTR(long error)
-{
-	return (void *) error;
-}
-
-static inline long PTR_ERR(const void *ptr)
-{
-	return (long) ptr;
-}
-
-static inline long IS_ERR(const void *ptr)
-{
-	return IS_ERR_VALUE((unsigned long)ptr);
-}
-
-/* module */
-#define THIS_MODULE		0
-#define try_module_get(...)	1
-#define module_put(...)		do { } while (0)
-#define module_init(...)
-#define module_exit(...)
-#define EXPORT_SYMBOL(...)
-#define EXPORT_SYMBOL_GPL(...)
-#define module_param_call(...)
-#define MODULE_PARM_DESC(...)
-#define MODULE_VERSION(...)
-#define MODULE_DESCRIPTION(...)
-#define MODULE_AUTHOR(...)
-#define MODULE_LICENSE(...)
 
 #ifndef __UBIFS_H__
 #include "../drivers/mtd/ubi/ubi.h"
diff --git a/lib/Makefile b/lib/Makefile
index 9b1c2374b3..320197a520 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -59,6 +59,7 @@ obj-y += crc32.o
 obj-y += ctype.o
 obj-y += div64.o
 obj-y += hang.o
+obj-y += linux_compat.o
 obj-y += linux_string.o
 obj-$(CONFIG_REGEX) += slre.o
 obj-y += string.o
diff --git a/lib/linux_compat.c b/lib/linux_compat.c
new file mode 100644
index 0000000000..a3d4675f7e
--- /dev/null
+++ b/lib/linux_compat.c
@@ -0,0 +1,47 @@
+
+#include <common.h>
+#include <linux/compat.h>
+
+struct p_current cur = {
+	.pid = 1,
+};
+__maybe_unused struct p_current *current = &cur;
+
+unsigned long copy_from_user(void *dest, const void *src,
+		     unsigned long count)
+{
+	memcpy((void *)dest, (void *)src, count);
+	return 0;
+}
+
+void *kmalloc(size_t size, int flags)
+{
+	return memalign(ARCH_DMA_MINALIGN, size);
+}
+
+void *kzalloc(size_t size, int flags)
+{
+	void *ptr = kmalloc(size, flags);
+	memset(ptr, 0, size);
+	return ptr;
+}
+
+void *vzalloc(unsigned long size)
+{
+	return kzalloc(size, 0);
+}
+
+struct kmem_cache *get_mem(int element_sz)
+{
+	struct kmem_cache *ret;
+
+	ret = memalign(ARCH_DMA_MINALIGN, sizeof(struct kmem_cache));
+	ret->sz = element_sz;
+
+	return ret;
+}
+
+void *kmem_cache_alloc(struct kmem_cache *obj, int flag)
+{
+	return memalign(ARCH_DMA_MINALIGN, obj->sz);
+}
-- 
2.11.0

