From 61befc704e230cda398ad4030fa9a40875e1add1 Mon Sep 17 00:00:00 2001
From: Luka Perkov <luka@openwrt.org>
Date: Sat, 2 Mar 2013 23:34:00 +0100
Subject: [PATCH 122/158] tools: add some helper tools for Lantiq SoCs

Signed-off-by: Luka Perkov Luka Perkov <luka@openwrt.org>
Signed-off-by: Daniel Schwierzeck <daniel.schwierzeck@gmail.com>
---
 tools/lantiq_bdi_conf.awk          | 116 ++++++++++++++++++++++++
 tools/lantiq_ram_extract_magic.awk |  69 ++++++++++++++
 tools/lantiq_ram_init_uart.awk     | 179 +++++++++++++++++++++++++++++++++++++
 tools/lantiq_uart_image.pl         | 170 +++++++++++++++++++++++++++++++++++
 4 files changed, 534 insertions(+)
 create mode 100755 tools/lantiq_bdi_conf.awk
 create mode 100755 tools/lantiq_ram_extract_magic.awk
 create mode 100755 tools/lantiq_ram_init_uart.awk
 create mode 100755 tools/lantiq_uart_image.pl

diff --git a/tools/lantiq_bdi_conf.awk b/tools/lantiq_bdi_conf.awk
new file mode 100755
index 0000000000..c732289b9a
--- /dev/null
+++ b/tools/lantiq_bdi_conf.awk
@@ -0,0 +1,116 @@
+#!/usr/bin/awk -f
+#
+# Copyright (C) 2013 Luka Perkov <luka@openwrt.org>
+# Copyright (C) 2013 Daniel Schwierzeck <daniel.schwierzeck@gmail.com>
+#
+# Usage:
+#  awk -f lantiq_bdi_conf.awk -v soc=ar9 board=<name> PATH_TO_BOARD/ddr_settings.h
+#
+# Additional information:
+#  http://www.abatron.ch/fileadmin/user_upload/products/pdf/ManGDBR4K-3000.pdf
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+function print_header()
+{
+	print ";                                                                         "
+	print "; Copyright (C) 2013 Luka Perkov <luka@openwrt.org>                       "
+	print "; Copyright (C) 2013 Daniel Schwierzeck <daniel.schwierzeck@gmail.com>    "
+	print ";                                                                         "
+	print "; This file has been generated with lantiq_bdi_conf.awk script.           "
+	print ";                                                                         "
+	print "; SPDX-License-Identifier:	GPL-2.0+                                 "
+	print ";                                                                         "
+	print ""
+}
+
+function init_ar9_prologue()
+{
+	print "WM32 0xBF103010 0x80		; CGU for CPU 333Mhz, DDR 167Mhz"
+	print "WM32 0xBF103014 0x01		; CGU update"
+	print "WM32 0xBF800010 0x0		; Clear error access log register"
+	print "WM32 0xBF800020 0x0		; Clear error access log register"
+	print "WM32 0xBF800060 0xD		; Enable FPI, DDR and SRAM module in memory controller"
+	print "WM32 0xBF801030 0x0		; Clear start bit of DDR memory controller"
+}
+
+function init_ar9_epilogue()
+{
+	print "WM32 0xBE105360 0x4001D7FF	; EBU setup"
+}
+
+function init_ddr1_epilogue()
+{
+	print "WM32 0xBF801030 0x100		; Set start bit of DDR memory controller"
+}
+
+function ar9_target()
+{
+	print "CPUTYPE		M34K"
+	print "ENDIAN		BIG"
+	print "JTAGCLOCK	1"
+	print "BDIMODE		AGENT		; [ LOADONLY, AGENT ]"
+	print "RESET		JTAG		; [ NONE, JTAG, HARD ]"
+	print "POWERUP		100"
+	print "WAKEUP		100"
+	print "BREAKMODE	HARD		; [ SOFT, HARD ]"
+	print  "STEPMODE	SWBP		; [ JTAG, HWBP, SWBP ]"
+	print "VECTOR		CATCH"
+	print  "SCANSUCC	1 5"
+}
+
+function flash_p2601hnfx()
+{
+	print "CHIPTYPE	MIRRORX16"
+	print "CHIPSIZE	0x1000000"
+	print "BUSWIDTH	16"
+}
+
+BEGIN {
+	switch (soc) {
+	case "ar9":
+		reg_base = 0xbf801000
+		print_header()
+		print "[INIT]"
+		init_ar9_prologue()
+		break
+	default:
+		print "Invalid or no value for SoC specified!"
+		exit 1
+	}
+}
+
+/^#define/ {
+	/* DC03 contains MC enable bit and must not be set here */
+	if (tolower($2) != "mc_dc03_value")
+		printf("WM32 0x%x %s\n", reg_base, tolower($3))
+
+	reg_base += 0x10
+}
+
+END {
+	switch (soc) {
+	case "ar9":
+		init_ddr1_epilogue()
+		init_ar9_epilogue()
+		print ""
+		print "[TARGET]"
+		ar9_target()
+		print ""
+		print "[HOST]"
+		print "PROMPT		\"ar9> \""
+		print ""
+		break
+	default:
+	}
+
+	switch (board) {
+	case "p2601hnfx":
+		print "[FLASH]"
+		flash_p2601hnfx()
+		print ""
+		break
+	default:
+	}
+}
diff --git a/tools/lantiq_ram_extract_magic.awk b/tools/lantiq_ram_extract_magic.awk
new file mode 100755
index 0000000000..64f1cbc990
--- /dev/null
+++ b/tools/lantiq_ram_extract_magic.awk
@@ -0,0 +1,69 @@
+#
+# Copyright (C) 2011-2013 Luka Perkov <luka@openwrt.org>
+#
+# Usage:
+# mips-openwrt-linux-objdump -EB -b binary -m mips:isa32r2 -D YOUR_IMAGE_DUMP | awk -f lantiq_ram_extract_magic.awk
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+BEGIN {
+	print "/*                                                                            "
+	print " * Copyright (C) 2011-2013 Luka Perkov <luka@openwrt.org>                     "
+	print " *                                                                            "
+	print " * This file has been generated with lantiq_ram_extract_magic.awk script.     "
+	print " *                                                                            "
+	print " * SPDX-License-Identifier:	GPL-2.0+                                     "
+	print " */                                                                           "
+	print ""
+
+	mc_dc_value=0
+	mc_dc_number=0
+	right_section=0
+	mc_dc_value_print=0
+	mc_dc_number_print=0
+}
+
+/t2,[0-9]+$/ {
+	if (right_section) {
+		split($4, tmp, ",")
+		mc_dc_value=sprintf("%X", tmp[2])
+		mc_dc_value_print=1
+	}
+}
+
+/t2,0x[0-9a-f]+$/ {
+	if (right_section) {
+		split($4, tmp, ",0x")
+		mc_dc_value=sprintf("%s", tmp[2])
+		mc_dc_value=toupper(mc_dc_value)
+		mc_dc_value_print=1
+	}
+}
+
+/t2,[0-9]+\(t1\)$/ {
+	if (right_section) {
+		split($4, tmp, ",")
+		split(tmp[2], tmp, "(")
+		mc_dc_number=tmp[1]/16
+		mc_dc_number_print=1
+	}
+}
+
+{
+	if (right_section && mc_dc_number_print && mc_dc_value_print) {
+		if (mc_dc_number < 10)
+			print "#define MC_DC0" mc_dc_number "_VALUE\t0x" mc_dc_value
+		else
+			print "#define MC_DC" mc_dc_number "_VALUE\t0x" mc_dc_value
+		mc_dc_value_print=0
+		mc_dc_number_print=0
+	}
+
+	if ($4 == "t1,t1,0x1000")
+		right_section=1
+
+
+	if ($4 == "t2,736(t1)")
+		right_section=0
+}
diff --git a/tools/lantiq_ram_init_uart.awk b/tools/lantiq_ram_init_uart.awk
new file mode 100755
index 0000000000..b17bb8e435
--- /dev/null
+++ b/tools/lantiq_ram_init_uart.awk
@@ -0,0 +1,179 @@
+#!/usr/bin/awk -f
+#
+# Copyright (C) 2011-2012 Luka Perkov <luka@openwrt.org>
+# Copyright (C) 2012-2015 Daniel Schwierzeck <daniel.schwierzeck@gmail.com>
+#
+# Usage:
+# awk -f lantiq_ram_init_uart.awk -v soc=<danube|ar9|vr9|ar10> PATH_TO_BOARD/ddr_settings.h
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+function print_header()
+{
+	print ";                                                                            "
+	print "; Copyright (C) 2011-2013 Luka Perkov <luka@openwrt.org>                     "
+	print "; Copyright (C) 2012-2015 Daniel Schwierzeck <daniel.schwierzeck@gmail.com>  "
+	print ";                                                                            "
+	print "; This file has been generated with lantiq_ram_init_uart.awk script.         "
+	print ";                                                                            "
+	print "; SPDX-License-Identifier:	GPL-2.0+                                    "
+	print ""
+}
+
+function mc_danube_prologue()
+{
+	print ";Clear access error logs"
+	print "0xbf800010", "0x0"
+	print "0xbf800020", "0x0"
+
+	print ";Enable FPI and SRAM module in memory controller"
+	print "0xbf800060", "0x5"
+
+	print ";MC_DC03_VALUE -> halt memory controller"
+	print "0xbf801030", "0x0"
+}
+
+function mc_ar9_prologue()
+{
+	print ";Clear access error logs"
+	print "0xbf800010", "0x0"
+	print "0xbf800020", "0x0"
+
+	print ";Enable FPI, DDR and SRAM module in memory controller"
+	print "0xbf800060", "0xD"
+
+	print ";MC_DC03_VALUE -> halt memory controller"
+	print "0xbf801030", "0x0"
+}
+
+function mc_danube_epilogue()
+{
+	print ";MC_DC03_VALUE -> start memory controller"
+	print "0xbf801030", "0x100"
+}
+
+function mc_vr9_prologue()
+{
+	print ";MC_CCR07_VALUE -> halt memory controller"
+	print "0xbf401070", "0x0"
+}
+
+function mc_vr9_epilogue()
+{
+	print ";DDR_ECHO_DLL0"
+	print "0xbf400420", "0x24"
+	print ";DDR_ECHO_DLL1"
+	print "0xbf400428", "0x24"
+	print ";MC_CCR07_VALUE -> start memory controller"
+	printf("0xbf401070 0x%x\n", or(mc_ccr07_value, 0x100))
+}
+
+function mc_ar10_prologue()
+{
+	print ";MC_CCR00_VALUE -> halt memory controller"
+	print "0xbf801000", "0x0"
+}
+
+function mc_ar10_epilogue()
+{
+	print ";DDR_ECHO_DLL0"
+	print "0xbf8001d8", "0x20"
+	print ";DDR_ECHO_DLL1"
+	print "0xbf8001e0", "0x20"
+	print ";MC_CCR00_VALUE -> start memory controller"
+	print "0xbf801000", "0x401"
+}
+
+BEGIN {
+	switch (soc) {
+	case "danube":
+		dc_reg_base = 0xbf801000
+		print_header()
+		mc_danube_prologue()
+		break
+	case "ar9":
+		dc_reg_base = 0xbf801000
+		print_header()
+		mc_ar9_prologue()
+		break
+	case "vr9":
+		ccr_reg_base = 0xbf401000
+		print_header()
+		mc_vr9_prologue()
+		break
+	case "ar10":
+		ccr_reg_base = 0xbf801000
+		phyr_reg_base = 0xbf801400
+		print_header()
+		mc_ar10_prologue()
+		break
+	default:
+		print "Invalid or no value for soc specified!"
+		exit 1
+	}
+
+	mc_ccr07_value = 0
+	do_print = 1
+}
+
+/^#define[[:space:]]MC_DC03_VALUE[[:space:]]/ {
+	do_print = 0
+}
+
+/^#define[[:space:]]MC_CCR00_VALUE[[:space:]]/ {
+	if (soc == "ar10")
+		do_print = 0
+}
+
+/^#define[[:space:]]MC_CCR07_VALUE[[:space:]]/ {
+	if (soc == "vr9") {
+		mc_ccr07_value = strtonum($3)
+		do_print = 0
+	}
+}
+
+/^#define[[:space:]]MC_DC[[:digit:]][[:digit:]]_VALUE[[:space:]]/ {
+	if (do_print) {
+		printf(";%s\n", $2);
+		printf("0x%x %s\n", dc_reg_base, tolower($3))
+	} else {
+		do_print = 1
+	}
+
+	dc_reg_base += 0x10
+}
+
+/^#define[[:space:]]MC_CCR[[:digit:]][[:digit:]]_VALUE[[:space:]]/ {
+	if (do_print) {
+		printf(";%s\n", $2)
+		printf("0x%x %s\n", ccr_reg_base, tolower($3))
+	} else {
+		do_print = 1
+	}
+
+	ccr_reg_base += 0x10
+}
+
+/^#define[[:space:]]MC_PHYR[[:digit:]]_VALUE[[:space:]]/ {
+	printf(";%s\n", $2)
+	printf("0x%x %s\n", phyr_reg_base, tolower($3))
+
+	phyr_reg_base += 0x10
+}
+
+END {
+	switch (soc) {
+	case "danube":
+	case "ar9":
+		mc_danube_epilogue()
+		break
+	case "vr9":
+		mc_vr9_epilogue()
+		break
+	case "ar10":
+		mc_ar10_epilogue()
+		break
+	default:
+	}
+}
diff --git a/tools/lantiq_uart_image.pl b/tools/lantiq_uart_image.pl
new file mode 100755
index 0000000000..be6482bf66
--- /dev/null
+++ b/tools/lantiq_uart_image.pl
@@ -0,0 +1,170 @@
+#!/usr/bin/perl
+#
+# Copyright (C) 2005-2015 Lantiq Deutschland GmbH
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+#use strict;
+#use Cwd;
+#use Env;
+
+my $aline;
+my $lineid;
+my $length;
+my $address;
+my @bytes;
+my $addstr;
+my $chsum=0;
+my $count=0;
+my $firstime=1;
+my $i;
+my $currentaddr;
+my $tmp;
+my $holder="";
+my $loadaddr;
+
+if(@ARGV < 2){
+	die("\n Syntax: ./program_SDRAM input1(memory setup) input2(*\.srec) output\n");
+}
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput1 open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput2 open fail\n");
+open(OUTFILE, ">$ARGV[2]") || die("\nOutput file open fail\n");
+
+$i=0;
+while ($line = <INFILE1>){
+	if($line=~/\w/){
+		if($line!~/[;#\*]/){
+			if($i eq 0){
+				printf OUTFILE ("33333333");
+			}
+			chomp($line);
+			$line=~s/\t//;
+			@array=split(/ +/,$line);
+			$j=0;
+			while(@array[$j]!~/\w/){
+				$j=$j+1;
+			}
+			$addr=@array[$j];
+			$regval=@array[$j+1];
+			$addr=~s/0x//;
+			$regval=~s/0x//;
+			printf OUTFILE ("%08x%08x",hex($addr),hex($regval));
+			$i=$i+1;
+			if($i eq 8){
+				$i=0;
+				printf OUTFILE ("\n");
+			}
+		}
+	}
+}
+
+while($i lt 8 && $i gt 0){
+	printf OUTFILE "00"x8;
+	$i=$i+1;
+}
+
+if($i eq 8){
+	printf OUTFILE ("\n");
+}
+
+while($aline=<INFILE2>){
+	$aline=uc($aline);
+	chomp($aline);
+	next if(($aline=~/^S0/) || ($aline=~/^S7/));
+	($lineid, $length, $address, @bytes) = unpack"A2A2A8"."A2"x300, $aline;
+	$length = hex($length);
+	$address = hex($address);
+	$length -=5;
+	$i=0;
+
+	while($length>0){
+		if($firstime==1){
+			$addstr = sprintf("%x", $address);
+			$addstr = "0"x(8-length($addstr)).$addstr;
+			print OUTFILE $addstr;
+			addchsum($addstr);
+			$firstime=0;
+			$currentaddr=$address;
+			$loadaddr = $addstr;
+		}
+		else{
+			if($count==64){
+				$addstr = sprintf("%x", $currentaddr);
+				$addstr = "0"x(8-length($addstr)).$addstr;
+				print OUTFILE $addstr;
+				addchsum($addstr);
+				$count=0;
+			}
+			#printf("*** %x != %x\n", $address, $currentaddr) if $address != $currentaddr;
+		}
+		if($currentaddr < $address) {
+			print OUTFILE "00";
+			addchsum("00");
+			$count++;
+			$currentaddr++;
+		}
+		else {
+			while($count<64){
+				$bytes[$i]=~tr/ABCDEF/abcdef/;
+				print OUTFILE "$bytes[$i]";
+				addchsum($bytes[$i]);
+				$i++;
+				$count++;
+				$currentaddr++;
+				$length--;
+				last if($length==0);
+			}
+		}
+		if($count==64){
+			print OUTFILE "\n";
+			#print OUTFILE "\r";
+		}
+	}
+}
+if($count != 64){
+	$tmp = "00";
+	for($i=0;$i<(64-$count);$i++){
+		print OUTFILE "00";
+		addchsum($tmp);
+	}
+	print OUTFILE "\n";
+	#print OUTFILE "\r";
+}
+
+
+print OUTFILE "11"x4;
+use integer;
+$chsum=$chsum & 0xffffffff;
+$chsum = sprintf("%X", $chsum);
+$chsum = "0"x(8-length($chsum)).$chsum;
+$chsum =~tr/ABCDEF/abcdef/;
+print OUTFILE $chsum;
+print OUTFILE "00"x60;
+print OUTFILE "\n";
+#print OUTFILE "\r";
+
+print OUTFILE "99"x4;
+print OUTFILE $loadaddr;
+print OUTFILE "00"x60;
+print OUTFILE "\n";
+#print OUTFILE "\r";
+
+
+close OUTFILE;
+#END of Program
+
+
+
+sub addchsum{
+	my $cc=$_[0];
+	$holder=$holder.$cc;
+	if(length($holder)==8){
+		$holder = hex($holder);
+		$chsum+=$holder;
+		$holder="";
+	}
+}
+#END
+
-- 
2.11.0

